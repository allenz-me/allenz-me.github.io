<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">主页</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2022-01-28T19:09:20&#43;08:00</updated>
    <id>https://allenz-me.github.io/</id>
    <link rel="alternate" type="text/html" href="https://allenz-me.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://allenz-me.github.io/atom.xml" />
    
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.89.4">Hugo</generator>
        <entry>
            <title type="text">Large-Scale Linear Optimization</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/operations/large-scale-linear-opt/" />
            <id>https://allenz-me.github.io/posts/operations/large-scale-linear-opt/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2022-01-26T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本文介绍大规模线性规划问题的求解思想。内容主要来源自 《Introduction to Linear O……</summary>
            
                <content type="html">&lt;p&gt;本文介绍大规模线性规划问题的求解思想。内容主要来源自 《Introduction to Linear Optimization》Chapter 6.&lt;/p&gt;
&lt;h2 id=&#34;delayed-column-generation&#34;&gt;Delayed column generation&lt;/h2&gt;
&lt;p&gt;考虑一个非退化的线性规划的标准问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{cl}
\min  &amp;amp; c^T x \
\text{s.t.} &amp;amp; Ax = b, x \geq 0
\end{array}\tag{1}
$$&lt;/p&gt;
&lt;p&gt;假如说矩阵 $A\in \mathrm{R}^{m \times n}$ 的列数非常大，即 $n \gg m$，这时候我们无法把所有的列都放入内存执行计算。但是，注意到问题只有 $m$ 个基变量，也就是说我们只需要找到 $n$ 列中特定的 $m$ 列，就可以完成单纯型法的迭代，找到最优解了！&lt;/p&gt;
&lt;p&gt;我们可以先随便选取一组基变量进行计算， 接着我们就要去找 entering variable，找进基变量的准则是 reduced cost $\bar{c}_j = c_j - c_B^T B^{-1} A_j &amp;lt; 0$。当然，一般会选择 $\bar{c}_j$ 最小的指标 $j$ 进基，这就归结于问题：&lt;/p&gt;
&lt;p&gt;$$
\min ;\bar{c}_j = c_j - c_B^T B^{-1} A_j
$$&lt;/p&gt;
&lt;p&gt;对于一些具有特殊结构的线性规划，只要如上的问题可以轻松解决，即找到进基指标 $j$ 和相应的列 $A_j$，那么原问题就可以得到高效地求解！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：矩阵 $B$ 可以借助 revised simplex 方法进行迭代，因此计算量也是小的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下料问题是一个经典的、可以使用列生成算法来求解的问题。&lt;/p&gt;
&lt;h2 id=&#34;cutting-stock-problem&#34;&gt;Cutting-stock problem&lt;/h2&gt;
&lt;p&gt;下料问题由Kantorovich在1939年提出，是一个 NP-Hard 问题。&lt;/p&gt;
&lt;p&gt;假设一个造纸厂生产长度为 $W$ 的纸，然而，$m$ 个顾客需要的是 $b_i$ 卷长度为 $w_i &amp;lt; W$ 的纸（$i=1, \dots, m$）。那么，造纸厂最少需要多少卷纸来满足顾客的需求呢？&lt;/p&gt;
&lt;p&gt;为了解决这个问题，用一个列向量 $A_j = [a_{ij}]&lt;em&gt;{m \times 1}$ 表示一卷长度为 $W$ 的纸是如何切割成若干个长度为 $w_i$ 的纸的，其中 $a&lt;/em&gt;{ij}$ 表示第 $j$ 种切法中切出长度为 $w_i$ 的纸的数量。这样的话，对于一个向量 $[a_{1j}, a_{2j}, \dots, a_{mj}]^T$ ，它成为一种可行的切法的充要条件是满足：&lt;/p&gt;
&lt;p&gt;$$
A_j^T  {w} =\sum_{i=1}^m a_{ij} w_i \leq W, \quad a_{ij} \in \mathrm{N}
$$&lt;/p&gt;
&lt;p&gt;令矩阵 $A=[A_j]_{1\times n} \in \mathrm{R}^{m\times n}$ 表示所有可行的切割方法，注意到 $n$ 可能非常大，这会给问题带来困难。&lt;/p&gt;
&lt;p&gt;下料问题归结为一下优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;&amp;amp; \sum_{j=1}^n x_j \
\text{s.t.} ;&amp;amp; \sum_{j=1}^n a_{ij}x_j \geq b_i, ;; i =1, 2, \dots, m \
&amp;amp; : x_j \geq 0, ;; x_j \in \mathbb{N},  ;; j = 1, 2, \dots, n
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;决策变量 $x_j$ 表示第 $j$ 种切割方法执行的数量。这是一个整数规划问题，把整数条件放松掉，我们求解一个线性规划问题能轻松得到原整数规划问题的一个上界。（向上取整即可），于是其线性松弛可以表示为：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;&amp;amp; \sum_{j=1}^n x_j \
\text{s.t.} ;&amp;amp; \sum_{j=1}^n a_{ij}x_j = b_i, ;; i =1, 2, \dots, m \
&amp;amp; : x_j \geq 0,  ;; j = 1, 2, \dots, n
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;注意到 $n \gg m$，可行的切割方案数是非常大的，所以，这里可以使用 delayed column generation 的思想。不妨初始化设置 $B = I_{m\times m}$，接下来解优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;&amp;amp; 1 - c_B^T B^{-1} A_j \
\text{s.t.} ;&amp;amp; [w_1, \dots, w_m] A_j \leq W, \quad a_{ij} \in \mathbb{N} \
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;找到合适的进基变量和对应的列 $A_j$. 这里的目标函数是变量 $x_j$ 在单纯型表中的系数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意到这里是一个整数规划问题，但是可以用动态规划算法以伪多项式的时间内求解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来用 revised simplex 更新矩阵 $B$. 迭代到上述问题的最优值大于等于0的时候，原问题达到最优，单纯型迭代停止。这样我们就解决了一个整数规划的线性松弛问题。&lt;/p&gt;
&lt;p&gt;最后，对线性松弛最优解向上取证，可得： IP-optimal cost $\leq$ LP-optimal cost + $m$. 在 $m$ 较小的时候，这是一个良好的近似解。&lt;/p&gt;
&lt;h2 id=&#34;cutting-plane-method&#34;&gt;Cutting-plane method&lt;/h2&gt;
&lt;p&gt;列生成算法针对的是线性规划中列数特别多的情况，而切平面方法针对的是约束条件特别多的情况。这两种方法的联系可以理解为，列生成针对的是原问题，而切平面解决的是对偶问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{cl}
\max  &amp;amp; p^T b \
\text{s.t.} &amp;amp; p^T A \leq c^T
\end{array} \tag{2}
$$&lt;/p&gt;
&lt;p&gt;注意到，如果 $A_{m\times n}$ 的列数 $n$ 非常大时，上述问题的约束条件非常之多，使得单纯型法的基变量个数也非常多。&lt;/p&gt;
&lt;p&gt;类似地，我们没有必要同时考虑所有的约束条件，如果我们考虑一个子集上的：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{cl}
\max  &amp;amp; p^T b \
\text{s.t.} &amp;amp; p^T A_i \leq c_i , ;; i \in I
\end{array}
$$&lt;/p&gt;
&lt;p&gt;计算出的最优值 $\bar{p}$ 是问题(2)的可行解，那么 $\bar{p}$ 就一定是(2)的最优解！&lt;/p&gt;
&lt;p&gt;如果不可行，那么，求解&lt;/p&gt;
&lt;p&gt;$$
\min ;c_i - p^T A_i
$$&lt;/p&gt;
&lt;p&gt;找到一组使 $\bar{p}$ 不可行的约束条件和对应的 $A_i$ ，继续迭代就可以了。因此，cutting-plane method 能否应用归结于如上问题是否能高效求解！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;加入新的约束条件时，用对偶单纯型法继续迭代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对原问题执行列生成等价于对对偶问题执行切平面！&lt;/p&gt;
&lt;h2 id=&#34;dantzig-wolfe-decomposition&#34;&gt;Dantzig-Wolfe decomposition&lt;/h2&gt;
&lt;p&gt;考虑如下的线性规划：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ; &amp;amp;  {c}&lt;em&gt;{1}^{\prime}  {x}&lt;/em&gt;{1}+ {c}&lt;em&gt;{2}^{\prime}  {x}&lt;/em&gt;{2} \
\text { s.t. } &amp;amp;  {D}&lt;em&gt;{1}  {x}&lt;/em&gt;{1}+ {D}&lt;em&gt;{2}  {x}&lt;/em&gt;{2}= {b}&lt;em&gt;{0} \
&amp;amp;  {F}&lt;/em&gt;{1}  {x}&lt;em&gt;{1}= {b}&lt;/em&gt;{1} \
&amp;amp;  {F}&lt;em&gt;{2}  {x}&lt;/em&gt;{2}= {b}&lt;em&gt;{2} \
&amp;amp;  {x}&lt;/em&gt;{1},  {x}_{2} \geq  {0}
\end{aligned} \tag{3}
$$&lt;/p&gt;
&lt;p&gt;假设 $b_0, b_1, b_2$ 的维度分别是 $m_0, m_1, m_2$，对于 $m_1, m_2 \gg m_0$ 的情况，可以设计恰当的分解算法来高效求解。&lt;/p&gt;
&lt;p&gt;定义多面体&lt;/p&gt;
&lt;p&gt;$$
P_i = {x \mid F_i x = b_i}
$$&lt;/p&gt;
&lt;p&gt;于是原问题可以写成：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ; &amp;amp;  {c}&lt;em&gt;{1}^{\prime}  {x}&lt;/em&gt;{1}+ {c}&lt;em&gt;{2}^{\prime}  {x}&lt;/em&gt;{2} \
\text { s.t. } &amp;amp;  {D}&lt;em&gt;{1}  {x}&lt;/em&gt;{1}+ {D}&lt;em&gt;{2}  {x}&lt;/em&gt;{2}= {b}_{0} \
&amp;amp; x_1 \in P_1, ;; x_2 \in P_2
\end{aligned} \tag{4}
$$&lt;/p&gt;
&lt;p&gt;根据 Minkowski-Weyl 定理，一个 polyhedron 可以由若干个极点和极线构成，于是可以把 $x_1, x_2$ 改写成：&lt;/p&gt;
&lt;p&gt;$$
{x}&lt;em&gt;{i}=\sum&lt;/em&gt;{j \in J_{i}} \lambda_{i}^{j}  {x}&lt;em&gt;{i}^{j}+\sum&lt;/em&gt;{k \in K_{i}} \theta_{i}^{k}  {w}&lt;em&gt;{i}^{k}, \qquad \sum&lt;/em&gt;{j \in J_{i}} \lambda_{i}^{j}=1, ;; \lambda_i^j , \theta_i^k \geq 0 \quad i=1,2
$$&lt;/p&gt;
&lt;p&gt;其中 $J_i, K_i$ 分别表示 $P_1, P_2$ 的极点集，极线集。代入原问题，可得：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp; \sum_{j \in J_{1}} \lambda_{1}^{j}  {c}&lt;em&gt;{1}^{\prime}  {x}&lt;/em&gt;{1}^{j}+\sum_{k \in K_{1}} \theta_{1}^{k}  {c}&lt;em&gt;{1}^{\prime}  {w}&lt;/em&gt;{1}^{k}+\sum_{j \in J_{2}} \lambda_{2}^{j}  {c}&lt;em&gt;{2}^{\prime}  {x}&lt;/em&gt;{2}^{j}+\sum_{k \in K_{2}} \theta_{2}^{k}  {c}&lt;em&gt;{2}^{\prime}  {w}&lt;/em&gt;{2}^{k} \
\text { s.t. } &amp;amp; \sum_{j \in J_{1}} \lambda_{1}^{j}  {D}&lt;em&gt;{1}  {x}&lt;/em&gt;{1}^{j}+\sum_{k \in K_{1}} \theta_{1}^{k}  {D}&lt;em&gt;{1}  {w}&lt;/em&gt;{1}^{k}+\sum_{j \in J_{2}} \lambda_{2}^{j}  {D}&lt;em&gt;{2}  {x}&lt;/em&gt;{2}^{j}  + \sum_{k\in K_2}\theta_{2}^{k}  {D}&lt;em&gt;{2}  {w}&lt;/em&gt;{2}^{k}= {b}&lt;em&gt;{0} \
&amp;amp; \sum&lt;/em&gt;{j \in J_{1}} \lambda_{1}^{j}=1 \
&amp;amp; \sum_{j \in J_{2}} \lambda_{2}^{j}=1 \
&amp;amp; \lambda_{i}^{j} \geq 0, \theta_{i}^{k} \geq 0, \quad \forall i, j, k .
\end{aligned} \tag{DW-MP}
$$&lt;/p&gt;
&lt;p&gt;这个问题叫做 Dantzig-Wolfe master problem。注意到这个等价的问题只有 $m_0 + 2$ 个约束条件，当 $m_1, m_2$ 比较大的时候，它很好地降低了单纯型法的存储规模！但是呢，它的列数非常大（变量个数很多），一个多面体的极点、极线的个数是阶乘级别的；幸运的是，我们能够使用列生成的思想去解决它。&lt;/p&gt;
&lt;p&gt;首先我们没有必要同时考虑那么多个极点和极限，先只取一个很小的子集，构成一个 restricted master problem（RMP）。&lt;/p&gt;
&lt;p&gt;设 DW-RMP 的&lt;strong&gt;对偶最优解&lt;/strong&gt;是 $p = c_B^T B^{-1} = \begin{bmatrix} q &amp;amp; r_1 &amp;amp; r_2 \end{bmatrix}$，变量 $\lambda_1^j$ 的 reduced cost 是 $\left( {c}&lt;em&gt;{1}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{1}\right)  {x}&lt;em&gt;{1}^{j}-r&lt;/em&gt;{1}$，变量 $\theta_1^k$ 的 reduced cost 是 $\left( {c}&lt;em&gt;{1}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{1}\right)  {w}_{1}^{k}$. 接下来我们要去检验这些变量的检验数是否小于0，这归结于一个&lt;strong&gt;更小规模&lt;/strong&gt;的线性规划问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min; &amp;amp; \left( {c}&lt;em&gt;{1}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{1}\right)  {x}&lt;em&gt;{1} \
\text { s.t. }  &amp;amp;  {x}&lt;/em&gt;{1} \in P_{1}
\end{aligned} \tag{DW-SP}
$$&lt;/p&gt;
&lt;p&gt;这个问题叫做 Dantzig-Wolfe subproblem （DW-SP），&lt;strong&gt;子问题用来检验最优性&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;如果最优值是 $-\infty$，我们能找到一条极线使得 $\left( {c}&lt;em&gt;{1}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{1}\right)  {w}_{i}^{k} &amp;lt; 0$，这说明 $\theta_i^k$ 应该进基。&lt;/p&gt;
&lt;p&gt;又或者最优值小于 $r_1$ ，也就是能找到一个极点 $x_i^j$ 使得 $\left( {c}&lt;em&gt;{1}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{1}\right)  {x}&lt;em&gt;{1}^{j}-r&lt;/em&gt;{1} &amp;lt; 0$，这说明 $\lambda_i^j$ 应该进基。如果算出的最优值不小于 $r_1$，说明达到最优了~~！&lt;/p&gt;
&lt;p&gt;对另一组问题也是类似的：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ; &amp;amp;\left( {c}&lt;em&gt;{2}^{\prime}- {q}^{\prime}  {D}&lt;/em&gt;{2}\right)  {x}&lt;em&gt;{2} \
\text { s.t. } &amp;amp;  {x}&lt;/em&gt;{2} \in P_{2},
\end{aligned}\tag{DW-SP}
$$&lt;/p&gt;
&lt;p&gt;列生成在 DW 分解中扮演着非常重要的作用，把求解一个大问题分解成若干个小问题，使计算得到了简化。&lt;/p&gt;
&lt;p&gt;这个方法可以推广到多个可分离变量上：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp;  {c}&lt;em&gt;{1}^{\prime}  {x}&lt;/em&gt;{1}+ {c}&lt;em&gt;{2}^{\prime}  {x}&lt;/em&gt;{2}+\cdots+ {c}&lt;em&gt;{t}^{\prime}  {x}&lt;/em&gt;{t} \
\text { s.t. } &amp;amp;  {D}&lt;em&gt;{1}  {x}&lt;/em&gt;{1}+ {D}&lt;em&gt;{2}  {x}&lt;/em&gt;{2}+\cdots+ {D}&lt;em&gt;{t}  {x}&lt;/em&gt;{t}= {b}&lt;em&gt;{0} \
&amp;amp;  {F}&lt;/em&gt;{i}  {x}&lt;em&gt;{i}= {b}&lt;/em&gt;{i}, \quad i=1,2, \ldots, t, \
&amp;amp;  {x}&lt;em&gt;{1},  {x}&lt;/em&gt;{2}, \ldots,  {x}_{t} \geq  {0} .
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;甚至当 $t=1$ 的时候：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp;  {c}^{\prime}  {x} \
\text { s.t. }  &amp;amp;  {D}  {x}= {b}_{0} \
&amp;amp;  {F x} =  {b} \
&amp;amp;  {x} \geq  {0}
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;依然可以定义 $P = {x \mid Fx = b}$ ，再利用 $P$ 的极点、极线来简化问题。当然，DW 分解并不拘泥于等式约束，只要约束条件的“较难”的一部分能够表达成 polyhedron 的形式即可。&lt;/p&gt;
&lt;p&gt;经验上，DW 分解在迭代的一开始效果比较好，但是最优值的提升可能逐渐变慢，所以经常提前终止并输出一个次优解。&lt;/p&gt;
&lt;p&gt;此外，在迭代的过程中，我们还能逐步更新问题的上界和下界。&lt;/p&gt;
&lt;p&gt;DW-RMP 输出原问题的一个上界。&lt;/p&gt;
&lt;h2 id=&#34;stochastic-programming-and-benders-decomposition&#34;&gt;Stochastic programming and Benders decomposition&lt;/h2&gt;
&lt;p&gt;Benders 分解借用的是 cutting-plane 的思想。&lt;/p&gt;
&lt;p&gt;对如下的优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp; c^T x + f^T y \
\text { s.t. }  &amp;amp; Ax + By = b \
&amp;amp;  y \geq 0,  x \in X \subseteq \mathrm{R}^n
\end{aligned} \tag{5}
$$&lt;/p&gt;
&lt;p&gt;其中 $X$ 是一个 polyhedron。鉴于 $x, y$ 是关联（coupling）着的，问题的难度会变大。如果确定了 $x$ 能方便地计算出 $y$，那么就可以用 Benders 分解来使问题得到简化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 $x$ 还可以是整数变量，$y$ 是连续取值的。$x$ 确定了，求 $y$ 就是一个简单的线性规划了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，改写为关于 $x$ 的优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp; c^T x + z \
\text { s.t. } &amp;amp;  x \in X \subseteq \mathrm{R}^n
\end{aligned} \tag{6}
$$&lt;/p&gt;
&lt;p&gt;式(6)称为 BD-Master Problem，其中：&lt;/p&gt;
&lt;p&gt;$$
z = z(x)= \left [ \begin{aligned}
\min ;  &amp;amp;f^T y \
\text { s.t. }  &amp;amp; Ax + By = b,  y \geq 0
\end{aligned}\right] = \left[
\begin{aligned}
\max ;  &amp;amp; ;\alpha^T (b-Ax)\
\text { s.t. }  &amp;amp; B^T \alpha \leq f
\end{aligned} \right]
$$&lt;/p&gt;
&lt;p&gt;根据假定（原问题关于 $x$ 困难而关于 $y$ 容易），给出 $x$，计算 $g(x)$ 是一件轻松的事情。但是，我们还得从对偶问题来计算 $g(x)$，&lt;strong&gt;注意到右侧的对偶问题的可行域是与 $x$ 无关的&lt;/strong&gt;。记右侧这个对偶问题为 BD-Subproblem。&lt;/p&gt;
&lt;p&gt;记多面体 $P = {\alpha \mid B^T \alpha \leq f}$，如果 $P$ 是空集，那么，由线性规划的弱对偶性，原问题无解（不可行）或者最优值无界。以下假设 $P$ 是非空的。&lt;/p&gt;
&lt;p&gt;式(6)可以改写为：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp; c^T x + z \
\text { s.t. } &amp;amp;  x \in X \subseteq \mathrm{R}^n \
&amp;amp; \alpha^T_i (b - Ax) \leq z,;; \forall \alpha_i \in J_P \
&amp;amp; \alpha_j^T (b - Ax) \leq 0, ;; \forall \alpha_j \in K_P
\end{aligned} \tag{7}
$$&lt;/p&gt;
&lt;p&gt;$J_P, K_P$ 分别表示 $P$ 的极点、极线组成的集合。注意到 Master Problem 的约束条件非常多。式(7)的最优值和式(5)是一样的。&lt;/p&gt;
&lt;p&gt;令 $J_P^\prime =K_P^\prime = \emptyset$，取一个 $x_0$ 开始迭代，如果对偶子问题无上界，那么这意味着原问题无解，解对偶子问题能得到一条极线 $w_0$，将   $w_0$ 加入到 $K_P^\prime$，这样的 $x_0$ 对于原始的问题(5)是不可行的！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$w_0$ 导致了一个 Benders feasibility cut.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在假定对偶子问题是有界的，那么说明 $x_0$ 是式(5)的可行解，于是我们能得到原始问题的一个上界 $\mathrm{UB} = c^T x_0 + z(x_0)$；同时，解 relaxed master problem：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\min ;  &amp;amp; c^T x + z \
\text { s.t. } &amp;amp;  x \in X \subseteq \mathrm{R}^n \
&amp;amp; \alpha^T_i (b - Ax) \leq z,;; \forall \alpha_i \in J_P^\prime \
&amp;amp; \alpha_j^T (b - Ax) \leq 0, ;; \forall \alpha_j \in K_P^\prime
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;可以得到一个下界 $\mathrm{LB}$，如果 $\mathrm{LB} = \mathrm{UB}$，那么迭代停止，输出最优解。如果 $\mathrm{UB} \geq \mathrm{LB}$，就要向 BD-RMP 添加 Benders optimality cut，在计算用对偶子问题计算 $z(x_0)$ 的时候，得到的极点 $v_0$ 加入到 $J_P^\prime$，继续迭代即可。&lt;/p&gt;
&lt;p&gt;Benders 分解解决的是一类具有特殊形式的规划问题，大规模随机规划刚好具有这样的形式。
$$
\begin{aligned}
\min ; &amp;amp;  c^T x &amp;amp;  + \alpha_1 f^T y_1  &amp;amp; +  \alpha_2 f^T y_2 + \dots &amp;amp; + \alpha_K f^T y_K \
\text{ s.t. } &amp;amp; Ax &amp;amp;   &amp;amp;   &amp;amp;&amp;amp;=b \
&amp;amp; B_1 x  &amp;amp; + Dy_1 &amp;amp;  &amp;amp; &amp;amp;=  d_1 \
&amp;amp; B_2 x  &amp;amp;  &amp;amp; +  D y_2 &amp;amp; &amp;amp;  = d_2 \
&amp;amp; \vdots &amp;amp;&amp;amp;&amp;amp;&amp;amp; \vdots \
&amp;amp; B_K x  &amp;amp;&amp;amp;&amp;amp; + Dy_K &amp;amp; = d_K \
&amp;amp; x, y_1, \dots, y_k \geq 0 \
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;Scenario 的个数 $K$ 一般很大，而第一阶段的决策 $x$ 确定下来之后，每个 $y_k$  的计算是若干个小的子问题。&lt;/p&gt;
&lt;p&gt;令：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
z_{\omega}(  {x})=  \left[
\begin{aligned}
\min ;&amp;amp;   {f}^{\top}   {y}&lt;em&gt;{\omega} \
\text { s.t. } &amp;amp;   {B}&lt;/em&gt;{\omega}   {x}+  {D}   {y}&lt;em&gt;{\omega}=  {d}&lt;/em&gt;{\omega} \
&amp;amp;   {y}&lt;em&gt;{\omega} \geq  {0} .
\end{aligned}\right]
\end{aligned} = \left[
\begin{aligned}
\max ;; &amp;amp;   {p}&lt;/em&gt;{\omega}^{\top}\left(  {d}&lt;em&gt;{\omega}-  {B}&lt;/em&gt;{\omega}   {x}\right) \
\text { s.t. } &amp;amp;   {p}_{\omega}^{\top}   {D} \leq   {f}^{\top}
\end{aligned}
\right]
$$&lt;/p&gt;
&lt;p&gt;问题化为关于 $x$ 的：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\min &amp;amp;   {c}^{\top}   {x}+\sum_{w=1}^{K} \alpha_{\omega} z_{\omega}(  {x}) \
\text { s.t. } &amp;amp;   {A x}=  {b} \
&amp;amp;   {x} \geq  {0} .
\end{array}
$$&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;本文总结了求解大规模线性规划问题的算法思路。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/" term="运筹与优化" label="运筹与优化" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/" term="线性规划" label="线性规划" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%A7%84%E5%88%92/" term="随机规划" label="随机规划" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Data-Driven Inventory Control with Shifting Demand</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/papers/2/" />
            <id>https://allenz-me.github.io/posts/papers/2/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2022-01-03T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">发表在 Production and Operations Management, 2021. DOI: https://doi.org/10.1111/poms.13326 文章研究数据驱动下需求分布会发生变化的库存管理。 Over a planning horizon of T periods, demand……</summary>
            
                <content type="html">&lt;p&gt;发表在 Production and Operations Management, 2021. DOI: &lt;a href=&#34;https://doi.org/10.1111/poms.13326&#34;&gt;https://doi.org/10.1111/poms.13326&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章研究数据驱动下&lt;strong&gt;需求分布会发生变化&lt;/strong&gt;的库存管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Over a planning horizon of T periods, demand distributions can change up to O( log T) times, but the ﬁrm does not know the demand distributions before or after each change, the time periods when changes occur, or the number of changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;lead-time 为0&lt;/strong&gt;，需求分布是离散、轻尾的，期望存在，方差有限，整体设定与通俗的库存管理相同。需求可能会变化 $V$ 次，目标是最小化：&lt;/p&gt;
&lt;p&gt;$$
\sum_{v=0}^{V} \sum_{t=l^{v}}^{l^{v+1}-1}\left(h, \mathbb{E}\left[\left(y_{t}-D_{t}^{v}\right)^{+}\right]+b\left[\left(D_{t}^{v}-y_{t}\right)^{+}\right]\right)
$$&lt;/p&gt;
&lt;p&gt;其中 $y_t$ 是当期的库存。不知道 lost sales，需求未满足时是不知道准确的需求的。&lt;/p&gt;
&lt;p&gt;用 regret 衡量 policy 的表现，研究 Regret(admissible policy) - Regret(best policy)。&lt;/p&gt;
&lt;p&gt;best policy 是假定需求分布和需求变化都已知的时候做出的最优 policy。&lt;/p&gt;
&lt;p&gt;文章首先证明了一个 lower bound:&lt;/p&gt;
&lt;p&gt;$$
R^{\pi}(\Lambda, T) \geq \frac{1}{40 e} \sqrt{T}
$$&lt;/p&gt;
&lt;p&gt;思路是构造 instance 并利用 KL 散度。跟 MAB 的 lower bound 证明有一点点类似？&lt;/p&gt;
&lt;p&gt;接着，文章给出了一个 Learning Algorithm for Inventory Control with Shifting Demand (LAIS) 算法并证明其 upper bound 是：&lt;/p&gt;
&lt;p&gt;$$
R^{L A I S}(\Lambda, T) \leq 2 \max {b, h} \sqrt{T}(\log T)(\log \log T)^{4}
$$&lt;/p&gt;
&lt;p&gt;这个算法把时间 $T$ 划分成 $O(\sqrt{T})$ 个 batch，每个 batch 首先花 $L=\left\lceil\log I(\log \log I)^{3}\right\rceil$ 时间做 exploration，剩下的时间做 exploitation。exploration 阶段把订货量设定的稍高，学习需求分布，接着再拿需求的经验分布当做真实分布的估计，做出一个样本上最优的 policy。&lt;/p&gt;
&lt;p&gt;文章还提到这个算法不适用于需求分布是连续的情况。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/" term="论文简读" label="论文简读" />
                            
                        
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">A practical inventory control policy using operational statistics</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/papers/1/" />
            <id>https://allenz-me.github.io/posts/papers/1/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2022-01-02T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">发表在 Operations Research Letters，2005. DOI: 文章较简短，但是对于 newsvender 问题给出了一个较为深刻的……</summary>
            
                <content type="html">&lt;p&gt;发表在 Operations Research Letters，2005. DOI:&lt;/p&gt;
&lt;p&gt;文章较简短，但是对于 newsvender 问题给出了一个较为深刻的结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The traditional approach of separating the parameter estimation and the maximization of the expected proﬁt leads to a suboptimal inventory policy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需求服从一个确定但是未知的分布，其它设定与经典的报童模型一致。&lt;/p&gt;
&lt;p&gt;经典的做法可能是积累需求的样本，然后用参数式/非参数统计拟合出一个分布，再代入到报童模型求解 $q^* = \bar{F}^{-1}(c/p).$&lt;/p&gt;
&lt;p&gt;但是，这样做可能导致一个严格非最优的订货量。&lt;/p&gt;
&lt;p&gt;文章以指数分布为例：&lt;/p&gt;
&lt;p&gt;假定需求服从均值 $\theta$ 的指数分布，则 $x^*(\theta) = \theta \ln (p/c)$.&lt;/p&gt;
&lt;p&gt;$\theta$ 的无偏估计由需求样本的均值给出：$\bar{D}=\displaystyle\frac{1}{n} \sum_{k=1}^{n} D_{k}$.&lt;/p&gt;
&lt;p&gt;所以经典统计方法给出的订货量是：&lt;/p&gt;
&lt;p&gt;$$
\hat{X}_{\mathrm{sm}}=\bar{D} \ln \left(p/c\right) \tag{sample mean}
$$&lt;/p&gt;
&lt;p&gt;然而，如果把样本均值的线性函数 $\hat{X}(z)=z \bar{D}$ 代入到利润函数里面，对 $z$ 进行优化：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\eta(z)
&amp;amp;=E\left[p \theta\left(1-\exp \left{-\frac{z \bar{D}}{\theta}\right}\right)-c z \bar{D}\right] \
&amp;amp;=p \theta\left(1-\left(\frac{n}{n+z}\right)^{n}\right)-c z \theta, \quad z \geqslant 0 .
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;可以得到：&lt;/p&gt;
&lt;p&gt;$$
\hat{X}_{\mathrm{os}: \mathrm{sm}}=\hat{X}\left(z^{*}\right)=n\left(\left(\frac{p}{c}\right)^{1 /(n+1)}-1\right) \bar{D} \tag{operational statistics}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 $p \gg c$ 时，$\hat{X}&lt;em&gt;{\mathrm{os}: \mathrm{sm}} &amp;gt; \hat{X}&lt;/em&gt;{\mathrm{sm}}$&lt;/p&gt;
&lt;p&gt;在我看来，估计需求分布的过程中没有考虑进多订、少订带来的不一样的影响，可能是 suboptimality 的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接把订货量当成需求样本的函数来进行计算的这种方法，文章称作是 operational statistics.&lt;/p&gt;
&lt;p&gt;可以严格证明 $\hat{X}&lt;em&gt;{\text{os:sm}}$ 产生的利润严格大于 $\hat{X}&lt;/em&gt;{\text{sm}}$ ！&lt;/p&gt;
&lt;p&gt;类似的影响出现于具有尺度参数（scale parameter）的分布族中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：文章中售价使用的是字母 $s$，而本文使用的是 $p$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- 

一个思路：对于正态分布的需求样本

1. 可以拟合一个神经网络（100 -&gt; 2）来计算正态分布的均值和方差，由此得到一个最优订货量
2. 以经验分布为目标分布，容易计算出一个最优订货量，由此训练一个神经网络（100-&gt;1）。

比较两者的优劣！

--&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/" term="论文简读" label="论文简读" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/newsvender/" term="Newsvender" label="Newsvender" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Concentration of sums of independent random variables</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/analysis/hdp2/" />
            <id>https://allenz-me.github.io/posts/analysis/hdp2/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本文总结自 高维概率 第二章 本书第二章主要讲的是多个独立随机变量的和，它们在均值附近的集……</summary>
            
                <content type="html">&lt;!-- #! https://zhuanlan.zhihu.com/p/413301756

# Concentration of sums of independent random variables --&gt;
&lt;p&gt;本文总结自 高维概率 第二章&lt;/p&gt;
&lt;!-- 本书：

[HDP-book.pdf](https://uploader.shimo.im/f/CwR4dIKrjpcCDJgR.pdf?fileGuid=DGdRyQyhVkdyvcWd)

某大佬做的视频链接：

[https://www.bilibili.com/video/BV1gZ4y1W7ED](https://www.bilibili.com/video/BV1gZ4y1W7ED)

[https://www.bilibili.com/video/BV1kQ4y1P7y9](https://www.bilibili.com/video/BV1kQ4y1P7y9) --&gt;
&lt;p&gt;本书第二章主要讲的是多个独立随机变量的和，它们在均值附近的集中程度。&lt;/p&gt;
&lt;h2 id=&#34;probability-concentration&#34;&gt;Probability Concentration&lt;/h2&gt;
&lt;p&gt;现在我们要考虑的是一个probability concentration的问题，也可以说是去研究概率分布的尾巴，就像这样：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}{|X-\mu|&amp;gt;t} \leq \text { something small. }\
$$&lt;/p&gt;
&lt;p&gt;在随机变量方差存在的情况下，我们有切比雪夫不等式。它利用到了随机变量的方差，而且它的界是紧的，即我们总可以构造出一个随机变量使切比雪夫不等式取等号。但是，对于一些常见的概率分布而言，无论是正态分布还是指数分布等，切比雪夫不等式给出的界都显得太过粗糙。&lt;/p&gt;
&lt;p&gt;最为经典的正态分布自然第一个成为我们的“靶子”，容易证明正态分布的尾巴是一个以指数速度 $\frac{1}{t}e^{-t^2/2}$ 收敛于 0 的。如果 $g \sim \mathcal{N}(0, 1)$，那么：&lt;/p&gt;
&lt;p&gt;$$
\left(\frac{1}{t}-\frac{1}{t^{3}}\right) \cdot \frac{1}{\sqrt{2 \pi}} e^{-t^{2} / 2} \leq \mathbb{P}{g \geq t} \leq \frac{1}{t} \cdot \frac{1}{\sqrt{2 \pi}} e^{-t^{2} / 2}\
$$&lt;/p&gt;
&lt;p&gt;这不难从正态分布的CDF推出。虽然中心极限定理告诉我们任何分布的标准化都趋向于正态分布，但是 CLT 的误差界却是 $1/\sqrt{N}$ 的（Berry-Esseen CLT），能保证的收敛速度很慢，我们无法借助它来严格推导任意分布的尾巴，这逼迫我们寻找新的方法。&lt;/p&gt;
&lt;h2 id=&#34;hoeffding-inequality&#34;&gt;Hoeffding Inequality&lt;/h2&gt;
&lt;p&gt;从对称伯努利分布的和出发，即设 $\mathbb{P}{X=-1}=\mathbb{P}{X=1}=\frac{1}{2}$，那么 $X$ 的矩母函数：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{E}[e^{\lambda X}] = \frac{e^\lambda + e^{-\lambda}}{2} \leq e^{\frac{\lambda^2}{2}}  \
$$&lt;/p&gt;
&lt;p&gt;从而：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{S_{n} = \sum_{i=1}^n X_i  \geq t\right}=\mathbb{P} \left{e^{\lambda S_{n}} \geq e^{\lambda t}\right} \leq \frac{E\left[e^{\lambda S_{n}}\right]}{e^{\lambda t}} = \frac{ \prod_{i=1}^n E\left[e^{\lambda X_{i}}\right]}{e^{\lambda t}}  \leq e^{\frac{n}{2}\lambda^2 - \lambda t} \
$$&lt;/p&gt;
&lt;p&gt;取 $\lambda = \displaystyle\frac{t}{n}$，就有 $\mathbb{P}{S_n \geq t } \leq e^{-\frac{t^2}{2n}}$ ；同时不难得到 $\mathbb{P}{S_n \geq \sqrt{-2n \ln \epsilon}} \leq \epsilon$，即 $S_n \sim O(\sqrt{n})$。&lt;/p&gt;
&lt;p&gt;我们借助矩母函数，说明了对称伯努利分布的和的尾巴是指数速度趋于0的。使用相同的方法，可以得到&lt;strong&gt;针对有界随机变量的Hoeffding不等式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$
\forall t &amp;gt; 0, \quad\mathbb{P}\left{\sum_{i=1}^{N}\left(X_{i}-\mathbb{E} X_{i}\right) \geq t\right} \leq \exp \left(-\frac{2 t^{2}}{\sum_{i=1}^{N}\left(M_{i}-m_{i}\right)^{2}}\right), \quad X_i \in [m_i, M_i]\
$$&lt;/p&gt;
&lt;p&gt;在推导的过程中，主要用到了 Hoeffding 引理 $\mathbb{E}[e^{\lambda (X - \mathbb{E}[X])}] \leq e^{\lambda^2(M-m)^2/8}$ 和技巧：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}(X \geq t) = \mathbb{P}(e^{\lambda X} \geq e^{\lambda t}) \leq \frac{\mathbb{E}[e^{\lambda X}]}{e^{\lambda t}}, ;\forall \lambda \geq 0 \Longrightarrow \mathbb{P}(X \geq t) \leq \min_{\lambda \geq 0} \frac{\mathbb{E}[e^{\lambda X}]}{e^{\lambda t}}\
$$&lt;/p&gt;
&lt;p&gt;$E[e^{\lambda X}]$ 是 $X$ 的矩母函数，独立随机变量和的矩母函数等于其矩母函数的乘积！&lt;/p&gt;
&lt;p&gt;注意到正态分布也成立Hoeffding不等式，但正态分布并不是有界的，这说明Hoeffding不等式可以在某些条件下推广到无界的分布，这也是我们提出次高斯分布的原因。&lt;/p&gt;
&lt;p&gt;通过Hoeffding不等式我们知道，有界随机变量的和，以及正态分布的尾巴是以 $e^{-t^2}$ 这一速度趋于0的，但并不是所有的分布都能达到这种速度。比如我们熟知的指数分布，它就是$e^{-t}$级别的收敛速度。&lt;/p&gt;
&lt;p&gt;Chernoff不等式对于0-1伯努利分布的和给出了一个更好的界，由二项分布的泊松近似可知参数为$\lambda$的泊松分布的右尾满足：$\forall t &amp;gt; \lambda, ; \mathbb{P}{X \geq t} \leq e^{-\lambda}\left(\frac{e \lambda}{t}\right)^{t}$，这说明泊松分布的尾的收敛速度是$e^{-t \ln t}$级别的。这个尾巴也可以从上面提到的技巧来证明。&lt;/p&gt;
&lt;h2 id=&#34;sub-gaussian-distribution&#34;&gt;Sub-gaussian Distribution&lt;/h2&gt;
&lt;p&gt;正态分布可能是以 $e^{-t^2}$ 为尾概率的最为典型的分布了，我们都知道正态分布出现均值外3个标准差的概率是很小的，它的集中度是很高的，这种良好性质又足以拓展到其它的分布，我想这也是次高斯分布提出的原因之一。&lt;/p&gt;
&lt;p&gt;次高斯分布一般都是值零均值的分布，零均值也能方便我们讨论问题，它有若干条等价定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X$ 的尾巴满足：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathbb{P}{|X| \geq t} \leq 2 \exp \left(-t^{2} / K_{1}^{2}\right) \quad \text { for all } t \geq 0 \
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X$ 的矩满足：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
|X|&lt;em&gt;{L^{p}}=\left(\mathbb{E}|X|^{p}\right)^{1 / p} \leq K&lt;/em&gt;{2} \sqrt{p} \quad \text { for all } p \geq 1 \
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X^2$ 的矩母函数满足：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathbb{E} \exp \left(\lambda^{2} X^{2}\right) \leq \exp \left(K_{3}^{2} \lambda^{2}\right) \quad \text { for all } \lambda \text { such that }|\lambda| \leq \frac{1}{K_{3}} \
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X^2$ 的矩母函数在某一点有界：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathbb{E} \exp \left(X^{2} / K_{4}^{2}\right) \leq 2 \
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X$ 的矩母函数满足：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathbb{E} \exp (\lambda X) \leq \exp \left(K_{5}^{2} \lambda^{2}\right) \quad \text { for all } \lambda \in \mathbb{R} \
$$&lt;/p&gt;
&lt;p&gt;除去分布的尾巴，&lt;strong&gt;矩母函数/高阶矩也能刻画分布的集中程度&lt;/strong&gt;。期望不存在的分布一定不是次高斯（次指数）分布！&lt;/p&gt;
&lt;p&gt;对于次高斯分布还有次高斯模（sub-gaussian norm）的概念：&lt;/p&gt;
&lt;p&gt;$$
|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}=\inf \left{t&amp;gt;0: \mathbb{E} \exp \left(X^{2} / t^{2}\right) \leq 2\right}\
$$&lt;/p&gt;
&lt;p&gt;次高斯模有界的分布都是次高斯分布。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;次高斯模和后面定义的次指数模都是相应函数族空间中的范数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似于正态分布方差具有可加性，次高斯随机变量的和的次高斯模满足：&lt;/p&gt;
&lt;p&gt;$$
\left|\sum_{i=1}^{N} X_{i}\right|&lt;em&gt;{\psi&lt;/em&gt;{2}}^{2} \leq C \sum_{i=1}^{N}\left|X_{i}\right|&lt;em&gt;{\psi&lt;/em&gt;{2}}^{2}\
$$&lt;/p&gt;
&lt;p&gt;这个性质使得我们可以推出次高斯分布和的&lt;strong&gt;广义Hoeffding不等式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\left|\sum_{i=1}^{N} X_{i}\right| \geq t\right} \leq 2 \exp \left(-\frac{c t^{2}}{\sum_{i=1}^{N}\left|X_{i}\right|&lt;em&gt;{\psi&lt;/em&gt;{2}}^{2}}\right)\
$$&lt;/p&gt;
&lt;p&gt;这就是说，次高斯分布和次高斯分布的和，它们的尾巴都具有 $e^{-t^2}$ 趋近于0的良好性质！&lt;/p&gt;
&lt;p&gt;另外，对于非零均值的分布，因为&lt;/p&gt;
&lt;p&gt;$$
|X-\mathbb{E} X|&lt;em&gt;{\psi&lt;/em&gt;{2}} \leq|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}+|\mathbb{E} X|&lt;em&gt;{\psi&lt;/em&gt;{2}} \Rightarrow |X-\mathbb{E} X|&lt;em&gt;{\psi&lt;/em&gt;{2}} \leq C|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}\
$$&lt;/p&gt;
&lt;p&gt;一样可以写出其零均值化后的形式。于是，广义的Hoeffding不等式与之前针对有界随机变量的Hoeffding不等式实现了优美的统一。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：有界随机变量的Hoeffding不等式的另一种推广是McDiarmid’s inequality，如果&lt;/em&gt;$f:\mathrm{R}^n \to \mathrm{R}$&lt;em&gt;是可测函数，&lt;/em&gt;$X$&lt;em&gt;是&lt;/em&gt;$n$&lt;em&gt;维随机向量，并且：&lt;/em&gt;
$$
\left|f\left(x_{1}, \ldots, x_{i}, \ldots, x_{n}\right)-f\left(x_{1}, \ldots, x_{i}^{\prime}, \ldots, x_{n}\right)\right| \leq c_{i}, \forall i =1, 2, ..., n\
$$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;那么：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}{f(X)-\mathbb{E} f(X) \geq t} \leq \exp \left(-\frac{2 t^{2}}{\sum_{i=1}^{n} c_{i}^{2}}\right)\
$$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意到取&lt;/em&gt;$f(X)=\sum_{i=1}^n X_i$&lt;em&gt;就刚好是Hoeffding不等式。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;sub-exponential-distributions&#34;&gt;Sub-exponential Distributions&lt;/h2&gt;
&lt;p&gt;次高斯分布拓展了高斯分布的尾概率的性质，但它还不够广泛，并不是所有的分布都有那么细的尾巴。比如说，正态分布的平方和，卡方分布，和指数分布等，它们的尾巴就只是 $e^{-t}$ 阶的。&lt;/p&gt;
&lt;p&gt;仿照次高斯分布，我们不难定义次指数分布，我觉得指数分布可以说是这类分布中最典型的了，&lt;/p&gt;
&lt;p&gt;同样地，还有次指数模的概念：&lt;/p&gt;
&lt;p&gt;$$
|X|&lt;em&gt;{\psi&lt;/em&gt;{1}}=\inf ,{t&amp;gt;0: \mathbb{E} \exp (|X| / t) \leq 2}\
$$&lt;/p&gt;
&lt;p&gt;结合两个定义，&lt;strong&gt;次高斯分布的平方恰好就是次指数分布&lt;/strong&gt;，并且$\left|X^{2}\right|&lt;em&gt;{\psi&lt;/em&gt;{1}}=|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}^{2}$。两个次高斯分布的积是次指数的，并且$|X Y|&lt;em&gt;{\psi&lt;/em&gt;{1}} \leq|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}|Y|&lt;em&gt;{\psi&lt;/em&gt;{2}}$。&lt;/p&gt;
&lt;p&gt;次指数分布有Bernstein不等式来刻画它的集中程度：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\left|\sum_{i=1}^{N} X_{i}\right| \geq t\right} \leq 2 \exp \left[-c \min \left(\frac{t^{2}}{\sum_{i=1}^{N}\left|X_{i}\right|&lt;em&gt;{\psi&lt;/em&gt;{1}}^{2}}, \frac{t}{\max &lt;em&gt;{i}\left|X&lt;/em&gt;{i}\right|&lt;em&gt;{\psi&lt;/em&gt;{1}}}\right)\right]\
$$&lt;/p&gt;
&lt;p&gt;该不等式也容易由$|X-\mathbb{E} X|&lt;em&gt;{\psi&lt;/em&gt;{1}} \leq C|X|&lt;em&gt;{\psi&lt;/em&gt;{1}}$推广到非零均值随机变量。&lt;/p&gt;
&lt;p&gt;Bernstein不等式的意思是，在均值附近，衰减速度是接近高斯分布的，远离均值的部分，则是以指数分布的速度衰减的，这与泊松分布（二项分布的极限）是类似的。Bernstein不等式下面这种形式反映了该思想：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\left|\frac{1}{\sqrt{N}} \sum_{i=1}^{N} X_{i}\right| \geq t\right} \leq\left{\begin{array}{ll}2 \exp \left(-c t^{2}\right), &amp;amp; t \leq C \sqrt{N} \2 \exp (-t \sqrt{N}), &amp;amp; t \geq C \sqrt{N}\end{array}\right.\
$$&lt;/p&gt;
&lt;p&gt;当$|X| \leq K$是有界随机变量的时候，Bernstein不等式还可以写为如下的形式：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\left|\sum_{i=1}^{N} X_{i}\right| \geq t\right} \leq 2 \exp \left(-\frac{t^{2} / 2}{\sigma^{2}+K t / 3}\right)\
$$&lt;/p&gt;
&lt;p&gt;本章的最后一节还提到了两个重要的不等式，其中一个是 McDiarmid 不等式，已经介绍过了，另一个是 Bennett 不等式：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\sum_{i=1}^{N}\left(X_{i}-\mathbb{E} X_{i}\right) \geq t\right} \leq \exp \left(-\frac{\sigma^{2}}{K^{2}} h\left(\frac{K t}{\sigma^{2}}\right)\right)\
$$&lt;/p&gt;
&lt;p&gt;其中 $| X_i - \mathbb{E}[X_i] | \leq K$，$\sigma^2 = \sum_{i=1}^N \operatorname{var}(X_i), ; h(u) = (1 + u) \ln (1 + u) - u.$&lt;/p&gt;
&lt;h2 id=&#34;further-thoughts&#34;&gt;Further Thoughts&lt;/h2&gt;
&lt;p&gt;本章主要讲的是如何去刻画随机变量的集中程度，由此提出了次高斯分布和次指数分布的这两个概念，它们是我们熟悉的正态分布和指数分布的推广。&lt;/p&gt;
&lt;p&gt;如果一个分布的尾巴比指数分布还要厚，比如它是多项式速度$t^{-k}$衰减到0的，统计学上称它为重尾分布（heavy-tail）。比如柯西分布、对数正态分布、某些帕累托分布。&lt;/p&gt;
&lt;p&gt;（离散）鞅可以由一串零均值独立随机变量相加而得，如果$X_0=0$，那么鞅差序列${X_n - X_{n-1}, n \geq 1}$是互不相关的（而不是独立的）。在此基础上有 Azuma 不等式：&lt;/p&gt;
&lt;p&gt;如果$| X_i - X_{i-1} | \leq c_i$，那么成立：&lt;/p&gt;
&lt;p&gt;$$
P(|X_n - X_0 | \geq a) \leq 2e^{-a^2 / (2 \sum_i c_i^2)}\
$$&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E5%88%86%E6%9E%90%E4%B8%8E%E6%A6%82%E7%8E%87/" term="分析与概率" label="分析与概率" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E9%AB%98%E7%BB%B4%E6%A6%82%E7%8E%87/" term="高维概率" label="高维概率" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/" term="正态分布" label="正态分布" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E6%AC%A1%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/" term="次高斯分布" label="次高斯分布" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Convex Function</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/operations/convex-function/" />
            <id>https://allenz-me.github.io/posts/operations/convex-function/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">说完了凸集，下一个要介绍的肯定就是凸函数啦~ 凸函数的相关性质在优化中的地位不言而喻~……</summary>
            
                <content type="html">&lt;!-- #! https://zhuanlan.zhihu.com/p/452821674

# Convex function --&gt;
&lt;p&gt;说完了凸集，下一个要介绍的肯定就是凸函数啦~&lt;/p&gt;
&lt;p&gt;凸函数的相关性质在优化中的地位不言而喻~！&lt;/p&gt;
&lt;h2 id=&#34;凸函数&#34;&gt;凸函数&lt;/h2&gt;
&lt;p&gt;$f: \mathrm{R}^n \to \mathrm{R}$ 是凸函数，如果 $f$ 的定义域是凸集，并且 $\forall x, y, \theta \in [0, 1]$ 成立：&lt;/p&gt;
&lt;p&gt;$$
f(\theta x+(1-\theta )y) \leq \theta f(x) + (1-\theta) f(y)\
$$&lt;/p&gt;
&lt;p&gt;如果 $\theta \in (0, 1), x\neq y$ 时上面的不等号严格成立，那么就说这个函数是&lt;strong&gt;严格凸&lt;/strong&gt;（strict convex）的。&lt;/p&gt;
&lt;p&gt;几何上看，凸函数要求 $(x, f(x))$ 和 $(y, f(y))$ 这条线段位于函数图形的上方。&lt;/p&gt;
&lt;p&gt;对应的，我们还有定义“凹函数”（concave function），当 $-f$ 是凸函数时，$f$ 被称为凹函数。&lt;/p&gt;
&lt;p&gt;对于仿射函数，它是既凸又凹的。同时，&lt;strong&gt;既凸又凹的函数只有仿射函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果 $f$ 是凸函数，那么 $g(t)=f(x+tv)$ 也是凸函数，反过来的结论也成立。&lt;strong&gt;这说明，凸函数限制在任何一条直线上都是凸的！&lt;/strong&gt; 凸函数的概念完全可以从欧式空间推广到一般的线性空间，&lt;strong&gt;在一般的线性空间上，这条性质成为我们判断凸函数的重要依据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;凸函数还具有良好的分析性质，比如，凸函数在它定义域的相对内点集上是连续的；凸函数的不连续点只可能出现在它的相对边界上。&lt;/p&gt;
&lt;h3 id=&#34;凸函数定义域延拓&#34;&gt;凸函数定义域延拓&lt;/h3&gt;
&lt;p&gt;有时候我们会把一个凸函数的定义域延拓到整个 $R^n$ 空间中：&lt;/p&gt;
&lt;p&gt;$$
\tilde{f}(x)=\left{\begin{array}{ll}f(x) &amp;amp; x \in \operatorname{dom} f \ \infty &amp;amp; x \notin \operatorname{dom} f\end{array}\right.\
$$&lt;/p&gt;
&lt;p&gt;可以证明，这样延拓的凸函数也满足凸函数的定义。（在定义好关于$\infty$的运算后）。这样的定义在函数表示上有一定的意义。&lt;/p&gt;
&lt;h3 id=&#34;indicator-function&#34;&gt;Indicator function&lt;/h3&gt;
&lt;p&gt;设 $C$ 是一个凸集，令函数 $I_C(x) = 0, \forall x \in C$，即在集合 $C$ 上的取值为0，此时：
$$
\tilde{I}_{C}(x)= \begin{cases}0 &amp;amp; x \in C \ \infty &amp;amp; x \notin C\end{cases}\
$$
$\tilde{I}_C$ 叫做集合 $C$ 的 indicator function。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Indicator function 的共轭函数是 support function：
$$
S_{C}(y) = \sup ,{ y^T x \mid x \in C}\
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;一阶条件first-order-condition&#34;&gt;一阶条件（first order condition）&lt;/h3&gt;
&lt;p&gt;可微的凸函数满足一阶条件：&lt;/p&gt;
&lt;p&gt;$$
f(y) \geq f(x)+\nabla f(x)^{T}(y-x)\quad\forall x,y \in \mathrm{dom}f\
$$&lt;/p&gt;
&lt;p&gt;这个不等式揭示了凸函数的局部特性，那就是在一点的切平面是整个函数的 &lt;strong&gt;global underestimate&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;如果上面的不等号严格成立，那么这个函数是严格凸的。这里的条件是&lt;strong&gt;充分必要&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id=&#34;二阶条件second-order-condition&#34;&gt;二阶条件（second order condition）&lt;/h3&gt;
&lt;p&gt;如果定义在&lt;strong&gt;开凸集&lt;/strong&gt;上的二阶可微函数 $f$ 满足 $\nabla^2f\succeq0$，那么 $f$ 是凸函数。&lt;/p&gt;
&lt;p&gt;如果 $\nabla^2f\succ0$，那么 $f$ 是严格凸的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 $f$ 严格凸时，不一定能推出 $\nabla^2f$ 正定。比如 $f(x)=x^4$，二阶导数在 $x=0$ 处为 $0$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于一阶条件和二阶条件的证明，要用到泰勒展开。在此从略。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;$$
f(x) = (1/2) x^T P x + q^T x + r\
$$&lt;/p&gt;
&lt;p&gt;因为 $\nabla^2 f = P$，所以，当 $P \succeq 0$ 正定时，$f$ 是凸函数；当 $P \preceq 0$ 负定时，$f$ 是凹函数。&lt;/p&gt;
&lt;h3 id=&#34;凸函数的例子&#34;&gt;凸函数的例子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指数函数、多项式函数，绝对值函数都是凸的；对数函数是凹的。&lt;/li&gt;
&lt;li&gt;最大值函数 $f(x)=\max &lt;em&gt;{i} x&lt;/em&gt;{i}$ 是凸的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{aligned}f(\theta x+(1-\theta) y) &amp;amp;=\max &lt;em&gt;{i}\left(\theta x&lt;/em&gt;{i}+(1-\theta) y_{i}\right) \&amp;amp; \leq \theta \max &lt;em&gt;{i} x&lt;/em&gt;{i}+(1-\theta) \max &lt;em&gt;{i} y&lt;/em&gt;{i} \&amp;amp;=\theta f(x)+(1-\theta) f(y) , \quad \theta \in [0,1]\end{aligned}\
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$f(x)=\log \left(e^{x_{1}}+\cdots+e^{x_{n}}\right)$ 在 $\mathbf{R}^{n}$ 上是凸的。有估计式：
$$
\max \left{x_{1}, \ldots, x_{n}\right} \leq f(x) \leq \max \left{x_{1}, \ldots, x_{n}\right}+\log n \
$$
这个函数是最大值函数的一个光滑近似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$f(x,y) = \displaystyle\frac{x^2}{y} (\operatorname{dom} f=\mathbf{R} \times \mathbf{R}_{++}=\left{(x, y) \in \mathbf{R}^{2} \mid y&amp;gt;0\right})$ 是一个 &lt;em&gt;Quadratic-over-linear function&lt;/em&gt;， 它是凸的。&lt;/li&gt;
&lt;li&gt;$f(x)=(\Pi_{i=1}^n x_i)^{\frac{1}{n}},x_i&amp;gt;0$ 是凹函数，容易证明 $\nabla^2f$ 是半负定的。&lt;/li&gt;
&lt;li&gt;$f(X)=\log \det X$ 是 $\mathrm{S}_{++}^n$ 上的凹函数。它是一个定义在矩阵空间上的函数。它的证明要用到线性空间中凸性的性质，即凸函数限制在任意一条直线都是凸的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;下水平集sublevel-sets&#34;&gt;下水平集（sublevel sets）&lt;/h3&gt;
&lt;p&gt;定义 $f: \mathbf{R}^n \to \mathbf{R}$ 的 $\alpha-\text{sublevel; set}$ 为：&lt;/p&gt;
&lt;p&gt;$$
C_{\alpha}={x \in \operatorname{dom} f \mid f(x) \leq \alpha}\
$$&lt;/p&gt;
&lt;p&gt;易证 $f$ 是凸函数的时候 $C_\alpha$ 是个凸集。（该性质说明凸函数是拟凸的）&lt;/p&gt;
&lt;p&gt;从而这里给出了判断凸集的另一个方法：&lt;strong&gt;能被写成某个凸函数的 &lt;em&gt;$\alpha$-sublevel set&lt;/em&gt; 的集合是凸集&lt;/strong&gt;。反之，一个函数的 sublevel set 是凸的，并不能反推出它是凸函数（事实上这个函数是拟凸的）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例：$S={x \mid x^T Ax+c^T x+ b \leq 0, A\succeq 0}$  是凸集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 $f$ 是凹函数有相应的结论：${x \in \operatorname{dom} f  \mid f(x) \geq \alpha}$ 是凸集。&lt;/p&gt;
&lt;h3 id=&#34;epigraph&#34;&gt;Epigraph&lt;/h3&gt;
&lt;p&gt;一个函数的 $f:\mathbf{R}^n\to \mathbf{R}$ 的 &lt;em&gt;epigraph&lt;/em&gt; 是指：&lt;/p&gt;
&lt;p&gt;$$
\text { epi } f={(x, t) \mid x \in \operatorname{dom} f, f(x) \leq t}\
$$&lt;/p&gt;
&lt;p&gt;$\text{epi} f$ 是 $\mathbf{R} ^{n+1}$ 的子集，是函数图形的上方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$\text{epi} f$ 是凸集当且仅当 $f$ 是凸函数。&lt;/strong&gt; 所以 epigraph 也是一种主要的判断凸函数的方法。这个证明非常容易，只需要反复使用定义即可。&lt;/p&gt;
&lt;p&gt;对应于凹函数我们定义 &lt;em&gt;hypograph&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;$$
\text { hypo } f={(x, t) \mid t \leq f(x)}\
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$\text{hypo} ;f$ 是凸集当且仅当 $f$ 是凹函数。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例：$f(X)=\lambda_{\max} (X), X \in \mathrm{S}&lt;em&gt;n$ 的 epigraph ${(X, t)\mid tI - X \succeq 0}$ 是凸集（由定义证），从而 $f$ 是凸函数。类似可得 $f(X)=\lambda&lt;/em&gt;{\min} (X), X \in \mathrm{S}_n$ 是凹函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;琴生不等式jesen-inequality&#34;&gt;琴生不等式（Jesen inequality）&lt;/h3&gt;
&lt;p&gt;琴生不等式是凸函数的重要性质。&lt;/p&gt;
&lt;p&gt;对 $x_{1}, \ldots, x_{k} \in \operatorname{dom} f$ 和 $\theta_{1}, \ldots, \theta_{k} \geq 0, \theta_{1}+\cdots+\theta_{k}=1$ 成立：&lt;/p&gt;
&lt;p&gt;$$
f\left(\theta_{1} x_{1}+\cdots+\theta_{k} x_{k}\right) \leq \theta_{1} f\left(x_{1}\right)+\cdots+\theta_{k} f\left(x_{k}\right)\
$$&lt;/p&gt;
&lt;p&gt;这是有限个点的情况。该不等式还能扩展到无限和、积分等情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If $p(x) \geq 0$ on $S \subseteq \operatorname{dom} f, \int_{S} p(x) \mathrm{d} x=1$, then:
$$
f \left( \int _ { S } p ( x ) x \mathrm{d} x \right) \leq \int _ { &amp;gt; S } f ( x ) p ( x ) \mathrm{d} x
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对某些凸函数应用琴生不等式可以得到许多著名的不等式，比如 Holder 不等式：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{n} x_{i} y_{i} \leq\left(\sum_{i=1}^{n}\left|x_{i}\right|^{p}\right)^{1 / p}\left(\sum_{i=1}^{n}\left|y_{i}\right|^{q}\right)^{1 / q}\
$$&lt;/p&gt;
&lt;h2 id=&#34;保持函数凸性的操作&#34;&gt;保持函数凸性的操作&lt;/h2&gt;
&lt;h3 id=&#34;若干凸函数非负的加权和&#34;&gt;若干凸函数非负的加权和&lt;/h3&gt;
&lt;p&gt;$f=w_1f_1 + w_2 f_2 + \cdots + w_n f_n$， $f_i$ 凸，$w_i &amp;gt; 0 \Longrightarrow f$ 凸。&lt;/p&gt;
&lt;p&gt;这意味着所有的凸函数形成了一个凸锥！&lt;/p&gt;
&lt;p&gt;可以推广到无穷和的情况，如果 $f(x,y)$ 对 $x$ 是凸的，并且 $w(y)&amp;gt;0$，那么 $g(x)=\displaystyle\int f(x,y)w(y) \mathrm{d}y$ 是凸的。&lt;/p&gt;
&lt;h3 id=&#34;与仿射函数的复合&#34;&gt;与仿射函数的复合&lt;/h3&gt;
&lt;p&gt;如果 $A$ 是一个矩阵，那么 $g(x)=f(A x+b)$ 与 $f$ 有相同的凹凸性。&lt;/p&gt;
&lt;p&gt;如果加上可微的条件，那么根据复合函数的求导法则，就有：
$$
\nabla g = A^T \nabla f, \quad \nabla^2 g = A^T \nabla^2 f A\
$$
所以显然 $g$ 与 $f$ 会有相同的凹凸性。&lt;/p&gt;
&lt;p&gt;例：$e^{ax+by+c}$ 是凸函数。&lt;/p&gt;
&lt;h3 id=&#34;逐点取最大值上确界&#34;&gt;逐点取最大值（上确界）&lt;/h3&gt;
&lt;p&gt;$f(x)=\max \left{f_{1}(x), \ldots, f_{m}(x)\right}$，$f_i$ 凸，则 $f$ 凸。对于凹函数，则是取最小值（下确界）。&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;infinite&lt;/em&gt; 的情况下，如果 $f(x,y)$ 对 $x$ 是凸的，那么 $g(x) = \displaystyle\sup_y f(x,y)$ 也是凸的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明要用到 epigraph，因为 $\operatorname{epi} g=\displaystyle\bigcap_{y \in \mathcal{A}} \operatorname{epi} f(\cdot, y)$，且凸集的交仍然是凸的，所以 $\operatorname{epi} g$ 也是凸的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;支撑函数 $S_C(x) = \sup {x^T y \mid y \in C}$，是一族线性函数的上确界，所以不管 $C$ 是不是凸集，$S_C$ 都是凸函数。&lt;/p&gt;
&lt;p&gt;$f(X) = \lambda_{\max} (X)$ 可以表示为 $\sup ,{y^TX y \mid |y |&lt;em&gt;2 = 1}$，是一列线性函数的上确界，所以 $\lambda&lt;/em&gt;{\max}$ 是凸函数。&lt;/p&gt;
&lt;p&gt;事实上，绝大多数的凸函数，都能够表示成一族仿射函数的上确界函数，这种方法也是判断凸函数最常用的方法。这与凸集可以表示成一族半平面的交，是一样的。（凸函数可以通过 epigraph 转换成凸集。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In other words, a convex function is the pointwise supremum of the set of all aﬃne global underestimators of it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;函数复合&#34;&gt;函数复合&lt;/h3&gt;
&lt;p&gt;考虑一般函数复合的情况：$f(x) = h(g(x))$&lt;/p&gt;
&lt;p&gt;在一元的情况下，求导可得：&lt;/p&gt;
&lt;p&gt;$$
f^{\prime \prime}(x)=h^{\prime \prime}(g(x)) g^{\prime}(x)^{2}+h^{\prime}(g(x)) g^{\prime \prime}(x)\
$$&lt;/p&gt;
&lt;p&gt;能够得到如下的判断法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$f$ is convex if $h$ is convex and nondecreasing, and $g$ is convex.&lt;/li&gt;
&lt;li&gt;$f$ is convex if $h$ is convex and nonincreasing, and $g$ is concave.&lt;/li&gt;
&lt;li&gt;$f$ is concave if $h$ is concave and nondecreasing, and $g$ is concave.&lt;/li&gt;
&lt;li&gt;$f$ is concave if $h$ is concave and nonincreasing, and $g$ is convex.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，&lt;strong&gt;凸函数批上一件单增且凸的外衣仍然是凸的&lt;/strong&gt;。当 $g$ 是多元函数的时候，上述法则仍然成立，只不过需要把 $h$ 换成延拓定义域之后的 $\tilde{h}$&lt;/p&gt;
&lt;p&gt;这个结论可以直接用定义证明。&lt;/p&gt;
&lt;p&gt;$g$ 是凸函数：$g(\theta x+(1-\theta) y) \leq \theta g(x)+(1-\theta) g(y)$&lt;/p&gt;
&lt;p&gt;$h$ 单调递增：$h(g(\theta x+(1-\theta) y)) \leq h(\theta g(x)+(1-\theta) g(y))$&lt;/p&gt;
&lt;p&gt;$h$ 是凸函数：$h(\theta g(x)+(1-\theta) g(y)) \leq \theta h(g(x))+(1-\theta) h(g(y))$&lt;/p&gt;
&lt;p&gt;结合起来有：$h(g(\theta x+(1-\theta) y)) \leq \theta h(g(x))+(1-\theta) h(g(y))$&lt;/p&gt;
&lt;h3 id=&#34;特殊情况下的下确界函数&#34;&gt;特殊情况下的下确界函数&lt;/h3&gt;
&lt;p&gt;如果 $f(x,y)$ 对 $(x,y)$ 是凸的，$C$ 是一个非空凸集，那么 $g(x)=\displaystyle\inf_{y \in C} ;f(x, y)$ 是凸的。&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}g\left(\theta x_{1}+(1-\theta) x_{2}\right) &amp;amp;=\inf &lt;em&gt;{y \in C} f\left(\theta x&lt;/em&gt;{1}+(1-\theta) x_{2}, y\right) \&amp;amp; \leq f\left(\theta x_{1}+(1-\theta) x_{2}, \theta y_{1}+(1-\theta) y_{2}\right) \&amp;amp; \leq \theta f\left(x_{1}, y_{1}\right)+(1-\theta) f\left(x_{2}, y_{2}\right) \&amp;amp; \leq \theta g\left(x_{1}\right)+(1-\theta) g\left(x_{2}\right)+\epsilon\end{aligned}\
$$&lt;/p&gt;
&lt;p&gt;另外，也可以通过 $\mathrm{epi };g$ 来证明凸性：
$$
\text { epi } g={(x, t) \mid(x, y, t) \in \text { epi } f \text { for some } y \in C}\
$$
是某个凸集的投影。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;点 $x$ 到集合$S$ 的距离：
$$
\operatorname{dist}(x, S)=\inf _{y \in S}|x-y|\
$$
当 $S$ 是凸集时，$\operatorname{dist}(x, S)$ 是凸函数。&lt;/p&gt;
&lt;h3 id=&#34;函数的透视&#34;&gt;函数的透视&lt;/h3&gt;
&lt;p&gt;透视操作是保持凸（凹）性的。&lt;/p&gt;
&lt;p&gt;如果 $f: \mathrm{R}^n \to \mathrm{R}$， $f$ 的透视（perspective）被定义为 $g : \mathrm{R}^{n+1} \to \mathrm{R}$：
$$
g(x, t) = t f(x/t)\
$$
$g$ 的定义域为 $\operatorname{dom} g={(x, t) \mid x / t \in \operatorname{dom} f, t&amp;gt;0}$&lt;/p&gt;
&lt;p&gt;$g$ 的凸性可以轻松由 epigraph 和凸集的透视仍然是凸的 来得到：
$$
\begin{aligned}(x, t, s) \in \mathbf{e p i} g &amp;amp; \Longleftrightarrow \quad t f(x / t) \leq s \&amp;amp; \Longleftrightarrow \quad f(x / t) \leq s / t \&amp;amp; \Longleftrightarrow \quad(x / t, s / t) \in \mathbf{e p i} f\end{aligned}\
$$
例：&lt;/p&gt;
&lt;p&gt;$f = -\log x$ 是 $\mathrm{R}_{++}$ 上的凸函数，则它的透视：
$$
g(x, t)=-t \log (x / t)=t \log (t / x)=t \log t-t \log x\
$$
也是凸的。&lt;/p&gt;
&lt;h2 id=&#34;共轭函数conjugate-function&#34;&gt;共轭函数（Conjugate Function）&lt;/h2&gt;
&lt;p&gt;这是一个非常重要的概念，在凸分析里，共轭函数有至关重要的地位！&lt;/p&gt;
&lt;p&gt;定义函数$f(x)$的共轭函数为：&lt;/p&gt;
&lt;p&gt;$$
f^{\ast}(y)=\sup _{x \in \operatorname{dom} f}\left(y^{T} x-f(x)\right)\
$$&lt;/p&gt;
&lt;p&gt;共轭函数是多个仿射函数的上确界，&lt;strong&gt;因此是一定是凸函数&lt;/strong&gt;。共轭函数的定义域是上确界值有限的 $y$ 的值。&lt;/p&gt;
&lt;p&gt;一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$f(x)=ax+b$，注意到 $xy-ax-b$ 只在 $y=a$ 时有界，因此共轭函数只在 $y=a$ 处有定义，并且 $f^\ast(y)=-b$&lt;/li&gt;
&lt;li&gt;$f(x)=x^2$，$\displaystyle\sup_{x\in R} xy - x^2 = \frac{y^2}{4}=f^\ast(y)$&lt;/li&gt;
&lt;li&gt;$f(x)=\frac{1}{2}x^T Qx,(Q\in \mathrm{S}^n_{++})$ 的共轭函数是 $f^\ast(y)=\frac{1}{2}y^T Q^{-1}y$&lt;/li&gt;
&lt;li&gt;$f(x)=|x|$ 的共轭函数是 $f^{\star}(y)=\left{\begin{array}{ll}0 &amp;amp; \text { if }|y| \leq 1 \ \infty &amp;amp; \text { if }|y|&amp;gt;1\end{array}\right.$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共轭函数具有鲜明的几何意义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-function/4308d11eac841b613a0a935ca6a0f26b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当 $f(x)$ 是一元函数的时候，如上图所示，$f^\ast(y)$ 表示以 $y$ 为斜率且过原点的直线，与$f(x)$ 的图像的最大距离（或者其负数）。&lt;/p&gt;
&lt;p&gt;当 $f(x)$ 是 $n$ 元函数的时候，$f^\ast(y)$ 表示以 $(-y, 1)$ 为法向量（n+1维）且过原点的平面，与 $f(x)$ 的图像的最大距离（或者其负数）。&lt;/p&gt;
&lt;p&gt;设$f(x)=|x|$代表$\mathbf{R}^n$中的一种范数，其对偶范数为$|\cdot |&lt;em&gt;\ast$，我们能得到共轭函数：
$$
f^{\ast}(y)=\left{\begin{array}{ll}0 &amp;amp; |y|&lt;/em&gt;\ast \leq 1 \ \infty &amp;amp; \text { otherwise }\end{array}\right.\
$$&lt;/p&gt;
&lt;h3 id=&#34;fenchels-inequality&#34;&gt;Fenchel’s inequality&lt;/h3&gt;
&lt;p&gt;根据共轭函数的定义，下式是显然的：&lt;/p&gt;
&lt;p&gt;$$
f(x)+f^\ast(y)\ge x^T y\
$$&lt;/p&gt;
&lt;p&gt;应用到上面的例子，还能得到：&lt;/p&gt;
&lt;p&gt;$$
x^{T} y \leq(1 / 2) x^{T} Q x+(1 / 2) y^{T} Q^{-1} y\
$$&lt;/p&gt;
&lt;h3 id=&#34;共轭函数的共轭&#34;&gt;共轭函数的共轭&lt;/h3&gt;
&lt;p&gt;如果 $f$ 是凸函数，并且$\mathbf{epi} f$是闭集，那么 $f^{\ast\ast}=f$。&lt;/p&gt;
&lt;h3 id=&#34;可微分函数的共轭&#34;&gt;可微分函数的共轭&lt;/h3&gt;
&lt;p&gt;如果 $f$ 是凸函数并且一阶可微，那么根据凸函数的极值理论，容易得到，使得 $y^T x-f(x)$ 最大的 $x^\ast$ 满足：&lt;/p&gt;
&lt;p&gt;$$
y=\nabla f(x^\ast)\
$$&lt;/p&gt;
&lt;p&gt;从而我们有：&lt;/p&gt;
&lt;p&gt;$$
f^{\ast}(y)=x^{* T} \nabla f\left(x^{\ast}\right)-f\left(x^{\ast}\right),\quad(y=\nabla f(x^\ast))\
$$&lt;/p&gt;
&lt;p&gt;欲求 $f^\ast(y)$，只需要解 $y=\nabla f(z)$ 得到向量 $z$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可微函数$f$的共轭，也叫做$f$的 &lt;strong&gt;Legendre变换&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;其他性质&#34;&gt;其他性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对 $a &amp;gt; 0, b \in \mathbf{R}$，$g(x)=af(x)+b$ 的共轭函数是 $g^{\ast}(y) = af^{\ast}(y/a) - b$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果$f(u, v)=f_{1}(u)+f_{2}(v)$，且$f_1, f_2$都是凸函数，那么：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
f^{\ast}(w, z)=f_{1}^{\ast}(w)+f_{2}^{\ast}(z)\
$$&lt;/p&gt;
&lt;h2 id=&#34;拟凸函数quasiconvex-functions&#34;&gt;拟凸函数（Quasiconvex functions）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;拟凸这节写的不是特别完善，挖坑以后填了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果一个函数的下水平集是凸的，那么就称这个函数是拟凸的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
S_{\alpha}={x \in \operatorname{dom} f \mid f(x) \leq \alpha} ;\text{  convex} \Longleftrightarrow f ;\text{  quasiconvex}\
$$&lt;/p&gt;
&lt;p&gt;$f$ 拟凹（quasiconcave）当且仅当 $-f$ 是拟凸的。即，对于拟凹的函数 $f$ 来说，上水平集 ${x \mid f(x) \geq \alpha}$ 是凸的。&lt;/p&gt;
&lt;p&gt;既拟凸又拟凹的函数叫做拟线性函数（quasilinear），拟线性函数的所有水平集 ${x \mid f(x) = \alpha}$ 都是凸的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凸函数一定是拟凸函数，但拟凸函数不一定是凸函数。&lt;/strong&gt; 比如 $f(x)=\sqrt{|x|}$ 就不是凸函数，但是是拟凸的。&lt;/p&gt;
&lt;p&gt;很多凸函数具有的良好性质，可以推广到拟凸函数上。&lt;/p&gt;
&lt;p&gt;一个定义在凸集上的函数是拟凸函数，&lt;strong&gt;当且仅当&lt;/strong&gt; $\forall x, y \in \mathrm{dom} f, 0\le \theta \le 1$，成立：
$$
f(\theta x+(1-\theta) y) \leq \max {f(x), f(y)}\
$$
这意味着，&lt;strong&gt;线段上的函数值，一定小于等于两个端点函数值最大的那一个&lt;/strong&gt;。这个既可以当做拟凸函数的性质，也能当做拟凸函数的定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拟凸（quasiconvex）两种等价定义的证明：&lt;/p&gt;
&lt;p&gt;$$
\forall \alpha , L_{\alpha}={x| f(x)\le \alpha}  \text{ convex}\Leftrightarrow f(\lambda x + (1-\lambda)y)\le \max{f(x), f(y)}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $f(\lambda x + (1-\lambda)y)\le \max{f(x), f(y)}$，那么 $\forall \alpha,$ 设 $x, y \in L_{\alpha}$，就有 $f(x)\le \alpha, f(y) \le \alpha$，从而&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
f(\lambda x+(1-\lambda )y)\le \max{f(x), f(y)}\le\alpha\
$$&lt;/p&gt;
&lt;p&gt;所以 $\lambda x+ (1-\lambda)y \in L_{\alpha}$，所以 $L_{\alpha}$ 是凸集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $L_{\alpha}$ 是凸集，$\forall x, y$， 设 $\alpha=\max {f(x), f(y)}$，从而 $x, y \in L_{\alpha}$，那么 $\lambda x + (1-\lambda) y \in L_{\alpha}$ 并且&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
f(\lambda x + (1-\lambda)y)\le\alpha= \max{f(x), f(y)}\
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时候，这个定义也叫做 Jensen&#39;s inequality for quasiconvex functions.&lt;/p&gt;
&lt;p&gt;针对这个性质还有另一个版本：
$$
f(x)\le f(y) \Rightarrow f(\theta x+(1-\theta)y)\le f(y)\
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些资料上把这个当做拟凸函数的定义，并且当不等号严格成立时，称$f$是&lt;strong&gt;严格拟凸&lt;/strong&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来看一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f(x_1, x_2)=x_1x_2, (x_1, x_2 &amp;gt; 0)$，容易看到 $\nabla^2 f$ 是不定的，因此既不是凸函数也不是凹函数。但是 ${x\mid x_1x_2\ge\alpha}$ 是凸集，所以 $f$ 是拟凹函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线性分式函数 $f(x)=\displaystyle\frac{a^{T} x+b}{c^{T} x+d} ; (\operatorname{dom} f=\left{x \mid c^{T} x+d&amp;gt;0\right})$ 是拟线性的，因为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{aligned}S_{\alpha} &amp;amp;=\left{x \mid c^{T} x+d&amp;gt;0,\left(a^{T} x+b\right) /\left(c^{T} x+d\right) \leq \alpha\right} \&amp;amp;=\left{x \mid c^{T} x+d&amp;gt;0, a^{T} x+b \leq \alpha\left(c^{T} x+d\right)\right}\end{aligned}\
$$&lt;/p&gt;
&lt;p&gt;是凸集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\operatorname{rank}(X+Y) \geq \min {\operatorname{rank} X, \operatorname{rank} Y}\
$$&lt;/p&gt;
&lt;p&gt;所以 $f(X)=\operatorname{rank}(X)$ 是 $\mathrm{S}_+^n$ 上的拟凹函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向上取整函数 $\operatorname{ceil}(x)=\inf {z \in \mathbf{Z} \mid z \geq x}$ 是拟凸的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mathrmr-上的拟凸函数&#34;&gt;$\mathrm{R}$ 上的拟凸函数&lt;/h3&gt;
&lt;p&gt;结合上述的性质，可以给出 $\mathrm{R}$ 上的拟凸函数的特性：&lt;/p&gt;
&lt;p&gt;$\mathrm{R}$ 上的拟凸函数，要么是单调的，要么在一个点左边单调递减，右边单调递增。&lt;/p&gt;
&lt;p&gt;所以 $\mathrm{R}$ 上的拟凸函数也满足至多是单峰的（unimodal）这一特点。&lt;/p&gt;
&lt;h3 id=&#34;可微分的拟凸函数&#34;&gt;可微分的拟凸函数&lt;/h3&gt;
&lt;p&gt;类似于凸函数，当函数可微时，可以推导出拟凸函数需要满足的一阶条件和二阶条件。&lt;/p&gt;
&lt;h4 id=&#34;一阶条件&#34;&gt;一阶条件&lt;/h4&gt;
&lt;p&gt;定义在凸集上的函数 $f$ 拟凸， 当且仅当 $\forall x, y \in \operatorname{dom} f$，有：&lt;/p&gt;
&lt;p&gt;$$
f(y) \leq f(x) \Longrightarrow \nabla f(x)^{T}(y-x) \leq 0\
$$&lt;/p&gt;
&lt;p&gt;该条件也有鲜明的几何意义。$\nabla f(x)$ 导出了过点 $x$ 的对下水平集 ${y\mid f(y)\le f(x)}$ 的支撑超平面。（高维情况很难想象，不妨考虑一维情况，这时候支撑超平面就退化为一个点，下水平集是一个区间）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-function/quasiconvex.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意到 $\nabla f(x_0)^T(y-x_0)=0$ 对于给定的 $x_0$，表示的是一个平面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然拟凸函数和凸函数在一阶条件上具有相似性，但是拟凸函数并不能用一阶条件来判断全局的最小值。使拟凸函数的梯度为0的点不一定是 global minimizer.&lt;/p&gt;
&lt;h4 id=&#34;二阶条件&#34;&gt;二阶条件&lt;/h4&gt;
&lt;p&gt;假如定义在凸集上的函数 $f$ 是二阶可微的，那么 $f$ 拟凸，当且仅当 $\forall x \in \operatorname{dom} f, y \in \mathrm{R}^n$ 有：&lt;/p&gt;
&lt;p&gt;$$
y^{T} \nabla f(x)=0 \Longrightarrow y^{T} \nabla^{2} f(x) y \geq 0\
$$&lt;/p&gt;
&lt;p&gt;在一维的情况下，这个条件简化为：&lt;/p&gt;
&lt;p&gt;$$
f^{\prime}(x)=0 \Longrightarrow f^{\prime \prime}(x) \geq 0\
$$&lt;/p&gt;
&lt;p&gt;这个条件，意味着 $\nabla^2 f$ 在 $\nabla f^{\perp}$ 是半正定的，暗示 $\nabla^2f$ 至多有一个负特征值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\mathrm{span}{\nabla f}$ 是一维的，从而 $\nabla f^{\perp}$是 $n-1$ 维的。如果 $\nabla^2f$ 在 $\nabla f^{\perp}$ 是正定的，那么才能说明 $f$ 是拟凸的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;保持拟凸性的操作&#34;&gt;保持拟凸性的操作&lt;/h3&gt;
&lt;h4 id=&#34;拟凸函数非负加权和的最大值&#34;&gt;拟凸函数非负加权和的最大值&lt;/h4&gt;
&lt;p&gt;这里就用之前提到过的第二种定义方式进行证明即可。同样可以推广到逐点上确界的情况。&lt;/p&gt;
&lt;p&gt;例：$\lambda_{\max }(X, Y)=\sup &lt;em&gt;{u \neq 0} \displaystyle\frac{u^{T} X u}{u^{T} Y u}=\sup {\lambda | \operatorname{det}(\lambda Y-X)=0}$，其中$X\in S^n, Y\in S^n&lt;/em&gt;{++}$，$\lambda_{\max}$是拟凸的，叫做 $(X,Y)$ 的广义特征值。&lt;/p&gt;
&lt;h4 id=&#34;函数复合-1&#34;&gt;函数复合&lt;/h4&gt;
&lt;p&gt;如果 $g: \mathrm{R}^n \to \mathrm{R}$ 是拟凸的，并且 $h: \mathrm{R} \to \mathrm{R}$ 是单调非减的，那么 $f = h \circ g$ 是拟凸的。&lt;/p&gt;
&lt;h4 id=&#34;最小化&#34;&gt;最小化&lt;/h4&gt;
&lt;p&gt;如果 $f(x, y)$ 对 $(x, y)$ 是拟凸的，并且 $C$ 是凸集，那么 $g(x) = \displaystyle\inf_{y \in C} f(x, y)$ 是拟凸的。&lt;/p&gt;
&lt;h2 id=&#34;对数凹对数凸函数&#34;&gt;对数凹/对数凸函数&lt;/h2&gt;
&lt;p&gt;简单讲，$f&amp;gt;0$，并且 $\log f$ 是凹函数，那么 $f$ 就称为对数凹的。&lt;/p&gt;
&lt;p&gt;对数凹还可以用 $f(\theta x+(1-\theta) y) \geq f(x)^{\theta} f(y)^{1-\theta}, \forall \theta \in [0, 1]$ 来定义。从这里看，凸函数可以视作一种“算术平均”，对数凸则是“几何平均”。&lt;/p&gt;
&lt;p&gt;如果 $h$ 凸，那么 $e^h$ 也是凸函数，从而我们知道，对数凸函数也是凸函数。&lt;/p&gt;
&lt;p&gt;对数凹函数常见于统计学。统计学中的似然函数，是一个经常要取对数的函数，&lt;strong&gt;欲求参数的极大似然估计值，其实就是一个关于似然函数的优化问题&lt;/strong&gt;，如果似然函数是对数凹的，那么求对数似然函数的最大值，就是一个凸优化问题！这是研究对数凹函数的目的所在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准正态分布的累计分布函数 $\Phi(x)=\displaystyle\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{x} e^{-u^{2} / 2} d u$ 是对数凹的。&lt;/li&gt;
&lt;li&gt;多元正态概率密度函数是 $f(x)=\displaystyle\frac{1}{\sqrt{(2 \pi)^{n} \operatorname{det} \Sigma}} e^{-\frac{1}{2}(x-\bar{x})^{T} \Sigma^{-1}(x-\bar{x})}$ 是对数凹的。&lt;/li&gt;
&lt;li&gt;指数分布的密度函数 $f(x) = \lambda e^{-\lambda x}$ 是对数凹的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事实上，很多常见的概率分布函数，都是对数凹的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 $f$ 具有良好的光滑性，通过 $\log f$ 的凹凸性，我们可以得到一些关于 $f$ 的性质：
因为：&lt;/p&gt;
&lt;p&gt;$$
\nabla^{2} \log f(x)=\frac{1}{f(x)} \nabla^{2} f(x)-\frac{1}{f(x)^{2}} \nabla f(x) \nabla f(x)^{T}\
$$&lt;/p&gt;
&lt;p&gt;于是可以得到 $f$ 对数凹的一个充要条件：&lt;/p&gt;
&lt;p&gt;$$
f(x) \nabla^{2} f(x) \preceq \nabla f(x) \nabla f(x)^{T}\
$$&lt;/p&gt;
&lt;p&gt;在一元函数的情况，就是：$f\cdot f^{&#39;&#39;}\leq(f^{&#39;})^2$&lt;/p&gt;
&lt;p&gt;此外，对数凸/凹性是对乘法保持封闭的。因为：&lt;/p&gt;
&lt;p&gt;$$
h(x)=f(x)g(x)\Rightarrow \log h(x) = \log f(x) + \log g(x)\
$$&lt;/p&gt;
&lt;p&gt;容易看出，&lt;strong&gt;如果概率密度函数是对数凹的，那么多个密度函数相乘的结果也是对数凹的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于积分，也有结果：&lt;/p&gt;
&lt;p&gt;$$
f ;\text{ log-concave} \Rightarrow g(x) = \int f(x, y)  \mathrm{d} y ;\text{ log-concave}\
$$&lt;/p&gt;
&lt;p&gt;应用到密度函数的卷积上：&lt;/p&gt;
&lt;p&gt;$$
(f * g)(x)=\int f(x-y) g(y) d y\
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这说明 $f, g$ 如果 log-concave，那么它们的卷积也是对数凹的！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;广义不等式下的凸性&#34;&gt;广义不等式下的凸性&lt;/h2&gt;
&lt;p&gt;通过上一章提到的广义不等式，可以借助 proper cone 定义多元函数的“单调递增”和“严格单调递增”。&lt;/p&gt;
&lt;p&gt;$f: \mathrm{R}^n \to \mathrm{R}$ 叫做 $K$&lt;em&gt;-nondecreasing&lt;/em&gt; 如果：&lt;/p&gt;
&lt;p&gt;$$
x \preceq_{K} y \Longrightarrow f(x) \leq f(y),\
$$&lt;/p&gt;
&lt;p&gt;K*-increasing* 如果：&lt;/p&gt;
&lt;p&gt;$$
x \preceq_{K} y, x \neq y \Longrightarrow f(x)&amp;lt;f(y) .\
$$&lt;/p&gt;
&lt;p&gt;类似可以定义 $K$&lt;em&gt;-nonincreasing&lt;/em&gt; 和 $K$&lt;em&gt;-decreasing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$f$ 是 $K=\mathrm{R}^n_+$ 上的 $K$&lt;em&gt;-nondecreasing&lt;/em&gt; 函数如果：$x_{1} \leq y_{1}, \ldots, x_{n} \leq y_{n} \Longrightarrow f(x) \leq f(y)$&lt;/li&gt;
&lt;li&gt;$f(X)=\mathrm{det} X$ 是 $\mathrm{S}^n_{+}$ 上的 &lt;em&gt;increasing&lt;/em&gt; 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果$X$是半正定矩阵，那么$|X+I|&amp;gt;|X|$。（借助特征值证明）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$f(X)=\mathrm{tr} X^{-1}$是 $\mathrm{S}^n_{++}$ 上的 &lt;em&gt;decreasing&lt;/em&gt; 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单调性的梯度条件&#34;&gt;单调性的梯度条件&lt;/h3&gt;
&lt;p&gt;对于这种新的单调性，我们可以用广义不等式下的梯度条件去判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$f$ is &lt;em&gt;K-nondecreasing&lt;/em&gt; $\Leftrightarrow$ $\nabla f(x) \succeq_{K^{\ast}} 0 \quad\forall x \in \mathrm{dom} f$&lt;/li&gt;
&lt;li&gt;$f$ is &lt;em&gt;K-increasing&lt;/em&gt; $\Leftrightarrow$ $\nabla f(x) \succ_{K^{\ast}} 0\quad\forall x \in \mathrm{dom} f$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数的梯度在对偶不等式的情况下是非负的。其实 $\nabla f(x) \succeq_{K^{\ast}} 0$ 这里暗指的，就是 $f$ 在 $K$ 中的每一个方向都是单调递增的。&lt;/p&gt;
&lt;h3 id=&#34;广义不等式下的凸性-1&#34;&gt;广义不等式下的凸性&lt;/h3&gt;
&lt;p&gt;进一步，通过 proper cone 还能把函数的凸性推广到向量值函数上：&lt;/p&gt;
&lt;p&gt;令 $K$ 是一个 proper cone，如果 $\forall x, y$，都有：&lt;/p&gt;
&lt;p&gt;$$
f(\theta x+(1-\theta) y) \preceq_{K} \theta f(x)+(1-\theta) f(y), \quad ;\forall \theta \in [0, 1]\
$$&lt;/p&gt;
&lt;p&gt;就说 $f$ 是 $K$&lt;em&gt;-convex&lt;/em&gt; 的。&lt;/p&gt;
&lt;p&gt;特别地，如果：&lt;/p&gt;
&lt;p&gt;$$
f(\theta x+(1-\theta) y) \prec_{K} \theta f(x)+(1-\theta) f(y), \quad ;\forall \theta \in (0,1)\
$$&lt;/p&gt;
&lt;p&gt;就说 $f$ 是 &lt;em&gt;strictly&lt;/em&gt; $K$&lt;em&gt;-convex&lt;/em&gt; 的。&lt;/p&gt;
&lt;p&gt;$f$ 的定义域不必拘泥于欧式空间！&lt;strong&gt;proper cone 定义好了序的关系，使我们可以研究任意向量空间到向量空间的映射的凸性！&lt;/strong&gt; 并且这种定义包容了我们通常理解的凸性。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;矩阵函数 $g: \mathrm{R}^{m \times n} \rightarrow \mathrm{S}^{n}$：&lt;/p&gt;
&lt;p&gt;$$
g(X)=X^{T} A X+B^{T} X+X^{T} B+C\
$$&lt;/p&gt;
&lt;p&gt;其中 $A \in \mathbf{S}^{m}, B \in \mathbf{R}^{m \times n}$,  $C \in \mathbf{S}^{n}$, 是凸函数当且仅当 $A \succeq 0$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第二部分&#34;&gt;第二部分&lt;/h2&gt;
&lt;p&gt;这是一条分割线，如果有时间，我会在下面继续补充一些重要的知识。&lt;/p&gt;
&lt;h3 id=&#34;一元凸函数的分析性质&#34;&gt;一元凸函数的分析性质&lt;/h3&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/" term="运筹与优化" label="运筹与优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E5%87%B8%E5%87%BD%E6%95%B0/" term="凸函数" label="凸函数" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E6%8B%9F%E5%87%B8%E5%87%BD%E6%95%B0/" term="拟凸函数" label="拟凸函数" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Convex Set</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/operations/convex-set/" />
            <id>https://allenz-me.github.io/posts/operations/convex-set/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">凸的背后，往往蕴含着非常好的性质，这也就是我们要去研究凸集的原因。凸，在优化理论扮演……</summary>
            
                <content type="html">&lt;!-- #! https://zhuanlan.zhihu.com/p/441144463

# Convex Set --&gt;
&lt;p&gt;凸的背后，往往蕴含着非常好的性质，这也就是我们要去研究凸集的原因。凸，在优化理论扮演着非常重要的角色。本文是我的一个注记，不会包含太多证明，主要取自Boyd的 《convex optimization》、GTM 264 《Functional Analysis, Calculus of Variations and Optimal Control》。&lt;/p&gt;
&lt;p&gt;未经特别说明，讨论的空间都是 $\mathrm{R}^n$ 。&lt;/p&gt;
&lt;h2 id=&#34;仿射和凸集&#34;&gt;仿射和凸集&lt;/h2&gt;
&lt;h3 id=&#34;仿射集&#34;&gt;仿射集&lt;/h3&gt;
&lt;p&gt;一个集合 $C$ 是仿射集（affine set），如果对任意 $x_1, x_2 \in C$ 和 $\theta \in \mathrm{R}$ 都有：&lt;/p&gt;
&lt;p&gt;$$
\theta x_1 + (1-\theta)x_2 \in C\
$$&lt;/p&gt;
&lt;p&gt;需要注意的是这里的 $\theta$ 取值是全体实数（而不是介于0到1之间）。这意味着仿射集中任意两点连成的直线位于集合内。&lt;/p&gt;
&lt;p&gt;仿射集可以写成一个线性子空间的仿射，即存在子空间 $V$ 使得：&lt;/p&gt;
&lt;p&gt;$$
C=V+x_{0}=\left{v+x_{0} \mid v \in V\right}\
$$&lt;/p&gt;
&lt;p&gt;类比非齐次线性方程组的解是一个仿射子集而对应的齐次线性方程组的解是一个线性子空间。&lt;/p&gt;
&lt;p&gt;对任意一个集合$C$，我们可以定义它的仿射包 （affine hull）：&lt;/p&gt;
&lt;p&gt;$$
\text { aff } C=\left{\theta_{1} x_{1}+\cdots+\theta_{k} x_{k} \mid x_{1}, \ldots, x_{k} \in C, \theta_{1}+\cdots+\theta_{k}=1\right}\
$$&lt;/p&gt;
&lt;p&gt;仿射包是包含这个集合的最小仿射集。通过仿射包可以定义相对内点（relative interior）这一概念。仿射集可以认为是一个平移后的子空间，所以仿射包能揭示一个集合真正的维度。&lt;/p&gt;
&lt;p&gt;相对内点与内点是有所不同的，比如考虑一个三维空间中的正方形。这个正方形内部的点，不是内点，但是是相对内点，只要我们把空间缩小为一个特定的二维空间，其相对内点就会变成真正的内点。再考虑三维空间中的一个球面，它的相对内点集是空集。&lt;/p&gt;
&lt;p&gt;相对内点准确的定义是：&lt;/p&gt;
&lt;p&gt;$$
\text { relint } C={x \in C \mid B(x, r) \cap \text { aff } C \subseteq C \text { for some } r&amp;gt;0}\
$$&lt;/p&gt;
&lt;p&gt;其中 $B(x, r)={y \mid|y-x| \leq r}$。通过相对内点还可以引出相对边界这一概念。还是上面那两个例子，正方形的相对边界就是正方形的四条边，球面的相对边界就是自己。&lt;/p&gt;
&lt;h3 id=&#34;凸集&#34;&gt;凸集&lt;/h3&gt;
&lt;p&gt;一个集合 $C$ 是凸集（convex set），如果对任意 $x_1, x_2 \in C$ 和 $\theta \in [0, 1]$ 都有：&lt;/p&gt;
&lt;p&gt;$$
\theta x_1 + (1-\theta)x_2 \in C\
$$&lt;/p&gt;
&lt;p&gt;仿射集自然是凸集的一种，类比于仿射集的相关概念，我们可以得到&lt;strong&gt;凸包&lt;/strong&gt;（&lt;em&gt;convex hull&lt;/em&gt; ）的定义：&lt;/p&gt;
&lt;p&gt;$$
\operatorname{conv} C=\left{\theta_{1} x_{1}+\cdots+\theta_{k} x_{k} \mid x_{i} \in C, \theta_{i} \geq 0, i=1, \ldots, k, \theta_{1}+\cdots+\theta_{k}=1\right}\
$$&lt;/p&gt;
&lt;p&gt;集合 $\mathrm{C}$ 的凸包是包含集合 $\mathrm{C}$ 的最小凸集。&lt;/p&gt;
&lt;h3 id=&#34;锥&#34;&gt;锥&lt;/h3&gt;
&lt;p&gt;在优化理论中，锥（Cones）是一个无限大的集合，与日常所接触的圆锥有所不同。&lt;/p&gt;
&lt;p&gt;一个集合$C$是锥，如果对任意 $x \in C$ 和 $\theta \geq 0$ 都有：&lt;/p&gt;
&lt;p&gt;$$
\theta x \in C\
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锥不一定是凸的&lt;/strong&gt;。如果一个锥是凸的，就称它是一个&lt;strong&gt;凸锥&lt;/strong&gt;（convex cone）。比如 $y=|x|$ 的图像就是一个锥，但不是凸锥。但是 $y\ge |x|$ 就是一个凸的锥了。注意到任何锥都包含原点 $\mathbf{0}$。&lt;/p&gt;
&lt;p&gt;类似的可以得到锥包（conic hull ），它是包含某个集合的最小的凸锥。&lt;/p&gt;
&lt;p&gt;$$
\operatorname{coni}(C) = {\theta_1 x_1 + \cdots +\theta_k x_k \mid x_i \in C, \theta_i \geq 0, i=1, ..., k}\
$$&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;下面列举一些凸集的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空集、一个点、一个线段、全空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超平面和半平面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\mathrm{R}^n$ 中超平面有形式：&lt;/p&gt;
&lt;p&gt;$$
\left{x \mid a^{T} x=b\right}, \quad a \neq 0\
$$&lt;/p&gt;
&lt;p&gt;$a$ 是这个超平面的法向。也可以写成：&lt;/p&gt;
&lt;p&gt;$$
\left{x \mid a^{T}\left(x-x_{0}\right)=0\right} ,\quad a \neq 0\
$$&lt;/p&gt;
&lt;p&gt;一个超平面将全空间分成了两个半平面，一个半平面有形式：&lt;/p&gt;
&lt;p&gt;$$
\left{x \mid a^{T} x\leq b\right}, \quad a \neq 0\
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;球、椭球&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欧式空间中的球有形式：&lt;/p&gt;
&lt;p&gt;$$
B\left(x_{c}, r\right)=\left{x \mid\left|x-x_{c}\right|&lt;em&gt;{2} \leq r\right}=\left{x \mid\left(x-x&lt;/em&gt;{c}\right)^{T}\left(x-x_{c}\right) \leq r^{2}\right}\
$$&lt;/p&gt;
&lt;p&gt;其中 $x_c$ 是球心，$r$ 是半径。另一种常用的表达方式是：&lt;/p&gt;
&lt;p&gt;$$
B\left(x_{c}, r\right)=\left{x_{c}+r u \mid|u|_{2} \leq 1\right}\
$$&lt;/p&gt;
&lt;p&gt;椭球会借助一个正定矩阵来表示：&lt;/p&gt;
&lt;p&gt;$$
\mathcal{E}=\left{x \mid\left(x-x_{c}\right)^{T} P^{-1}\left(x-x_{c}\right) \leq 1\right}\
$$&lt;/p&gt;
&lt;p&gt;$x_c$ 是椭球的球心，$P = P^T$ 是正定矩阵。椭球各个轴的方向是 $P$ 的特征向量的方向，每个半轴的长度是 $\sqrt{\lambda_i}$，即特征值开根号。另一种表达方式是：&lt;/p&gt;
&lt;p&gt;$$
\mathcal{E}=\left{x_{c}+A u \mid|u|_{2} \leq 1\right}\
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正规锥（norm cones）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
C={(x, t) ||x| \leq t} \subseteq \mathbf{R}^{n+1}\
$$&lt;/p&gt;
&lt;p&gt;也被叫做二阶锥（second order cones）、冰淇淋锥（ice-cream cones）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;凸多面体（polyhedron）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathcal{P}=\left{x | a_{j}^{T} x \leq b_{j}, j=1, \ldots, m, c_{j}^{T} x=d_{j}, j=1, \ldots, p\right}\
$$&lt;/p&gt;
&lt;p&gt;线性规划的可行域是一个 polyhedron；当一个 polyhedron 有界时，也经常叫 polytope。非负象限是一个特殊的 polyhedron：&lt;/p&gt;
&lt;p&gt;$$
\mathbf{R}&lt;em&gt;{+}^{n}=\left{x \in \mathbf{R}^{n} \mid x&lt;/em&gt;{i} \geq 0, i=1, \ldots, n\right}=\left{x \in \mathbf{R}^{n} \mid x \succeq 0\right}\
$$&lt;/p&gt;
&lt;p&gt;非负象限既是一个锥，也是一个凸多面体，因此有一个特殊的名称，polyhedral cone，一般可表示为 ${x \mid Ax \geq 0}$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单纯形 （simplex）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单纯形是一类重要的凸多面体，它由 $k+1$ 个不在同一个平面的点 $v_0, \dots, v_k \in \mathbf{R}^n$ 的凸组合构成。&lt;/p&gt;
&lt;p&gt;$$
C=\operatorname{conv}\left{v_{0}, \ldots, v_{k}\right}=\left{\theta_{0} v_{0}+\cdots+\theta_{k} v_{k} \mid \theta \succeq 0,1^{T} \theta=1\right}\
$$&lt;/p&gt;
&lt;p&gt;不同的两个点、不共线的三个点、不共面的四个点，它们生成的凸包，分别构成了一维、二维、三维的单纯形。&lt;/p&gt;
&lt;p&gt;特别地，unit simplex，或者说 probability simplex，由 $n$ 个直角坐标单位向量的凸组合构成：&lt;/p&gt;
&lt;p&gt;$$
x \succeq 0, \quad \mathbf{1}^{T} x \leq 1\
$$&lt;/p&gt;
&lt;p&gt;离散型随机变量的概率分布就是一个典型的 unit simplex。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半定矩阵锥（positive semideﬁnite cone）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们用记号 $\mathrm{S}^n$ 来表示所有的 $n$ 阶实对称矩阵组成的集合， $\mathrm{S}^n_+$ 表示所有的半正定矩阵，$\mathrm{S}^n_{++}$ 表示所有的正定矩阵。其中，$\mathrm{S}&lt;em&gt;{+}^n$ 是一个闭的 convex cone。所有的 $n$ 阶方阵是一个线性空间，$\mathrm{S}^n&lt;/em&gt;{+}$ 是这个线性空间的一个锥。
半定矩阵锥，让我们 &lt;strong&gt;对凸集的认识，从欧式空间，飞跃到了抽象的线性空间！&lt;/strong&gt; 这让我们得以在矩阵空间上考虑优化问题。这也是锥线性规划的起点！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几类重要的锥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个任意的集合 $C$，它边界点 $x_0$ 的 &lt;strong&gt;normal cone&lt;/strong&gt; 指的是集合 ${y \mid y^T (x - x_0) \leq 0,; \forall x \in C}$。即 $y$ 与任何以 $x_0$ 为端点的线段都不构成锐角。不论集合 $C$ 是什么，它的 normal cone 都是一个凸锥！&lt;/p&gt;
&lt;p&gt;对一个任意的集合 $C$，它的 &lt;strong&gt;barrier cone&lt;/strong&gt; 被定义为集合 ${y \mid |y^T x| &amp;lt; +\infty, ; \forall x \in C}$。即非零向量 $y$ 是包含 $C$ 的半平面 ${x \mid y^T x \leq \alpha}$ 的法向。不论集合 $C$ 是什么，它的 barrier cone 也是一个凸锥！&lt;/p&gt;
&lt;p&gt;对一个任意的集合 $C$，它的 &lt;strong&gt;recession cone&lt;/strong&gt; 被定义为集合 ${y \mid x - ty \in C, ;  \forall x \in C, ; \forall t \geq 0}$。$C$ 的回收锥可以理解为是所有可以无限延伸的方向生成的锥。凸集的 recession cone 是一个凸锥；特别地，多面体 ${x \mid Ax = b}$ 的 recession cone 是 ${y \mid Ay=0}$。&lt;/p&gt;
&lt;p&gt;如果 $C$ 是一个非空的闭凸集，那么 $C$ 的 recession cone 是它的 barrier cone 的对偶锥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几类概率约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个离散型随机变量 $X$，$P(X=a_i)=p_i, i=1,2,...n$，已知概率分布 $\vec{p}$ 构成一个标准的单纯形，这是一个凸集，且以下概率约束对 $\vec{p}$ 也是凸的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\alpha \leq \mathbb{E}f(X)\leq \beta$，其中 $f$ 是给定的函数&lt;/li&gt;
&lt;li&gt;$\mathbb{P}(X &amp;gt; \alpha)\leq \beta$&lt;/li&gt;
&lt;li&gt;$\mathbb{E}X^2\leq \alpha, ,  \mathbb{E}X^2 \geq \alpha$&lt;/li&gt;
&lt;li&gt;$\mathrm{Var}(X)\geq \alpha$（ $\mathrm{Var}(X) \leq \alpha$ 不是凸的约束）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，KL散度 $D_{KL}(p \lVert q)=\displaystyle\sum_{i=1}^n p_i \log \displaystyle\frac{p_i}{q_i}$ 对 $(p, q)$ 是凸的。&lt;/p&gt;
&lt;h3 id=&#34;凸集的表示&#34;&gt;凸集的表示&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Caratheodory’s theorem&lt;/strong&gt;：$S$ 是 $\mathrm{R}^n$ 的子集，那么， $x \in \operatorname{conv} S$，当且仅当存在一个至多包含 $S$ 中 $n+1$ 个点的 $A \subset S$，使得 $x$ 是 $A$ 中点的凸组合。&lt;/p&gt;
&lt;p&gt;这个定理反过来是显然的，如果 $x$ 是 $A$ 中点的凸组合，那么必然 $x \in \operatorname{conv} S$。&lt;/p&gt;
&lt;p&gt;现在设 $x \in \operatorname{conv} S$，那么根据凸包的定义，不妨设存在 $k &amp;gt; n, \lambda &lt;em&gt;i &amp;gt; 0$，使得 $x = \sum&lt;/em&gt;{i=0}^k \lambda_i x_i$， 现在 $x_i - x_0 : (1 \leq i \leq k)$ 这超过 $n$ 个的向量族必然是线性相关的，这样就可以采用线性相关的定义来证明 $x$ 只需要用 $k-1$ 个点的凸组合来表示就行了。&lt;/p&gt;
&lt;p&gt;例：设 $S = {(0, 0), (0, 1), (1, 1), (1,0)}$，$S$ 表示的是单位正方形的四个点，$\operatorname{conv} S$ 就是一个单位正方形。在这个单位正方形里随便取一个点，总能找到由 $S$ 中三个点组成的三角形覆盖住这个点。&lt;/p&gt;
&lt;p&gt;关于 $\operatorname{coni} S$ 成立一个类似的定理，只不过点数从 $n+1$ 减少到了 $n$ 个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Minkowski and Weyl&lt;/strong&gt;：polyhedron representation&lt;/p&gt;
&lt;p&gt;有界多面体可由其极点唯一决定。对于无界的多面体，可以由极点和方向来决定（extreme points and extreme rays）。这写下来就是：&lt;/p&gt;
&lt;p&gt;对任何 $P = {x \mid Ax \leq b}$，总能找到两个点集 $V, R$ ，使得：
$$
P = \operatorname{conv}(V) + \operatorname{coni}(R)\
$$
也就是说，多面体可以表示成一个凸集和一个锥的 Minkowski sum。这个定理在一些教材中也叫做 resolution theorem.&lt;/p&gt;
&lt;p&gt;参考：https://scaron.info/robotics/polyhedra-and-polytopes.html&lt;/p&gt;
&lt;h3 id=&#34;保持凸性的操作&#34;&gt;保持凸性的操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;凸集的交、和、差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 $C_1, C_2$ 是凸集，那么 $C_1 \bigcap C_2, ;C_1 + C_2, ; C_1 - C_2$ 是凸集。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;半正定矩阵锥是&lt;strong&gt;无穷多个&lt;/strong&gt;半平面的交：&lt;/p&gt;
&lt;p&gt;$$
\mathrm{S}^n_+=\bigcap_{z \neq 0}\left{X \in \mathbf{S}^{n} \mid z^{T} X z \geq 0\right}\
$$&lt;/p&gt;
&lt;p&gt;所以它是凸的。&lt;strong&gt;无穷多个凸集的交，仍然是凸集&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 $f(X) = z^T Xz$ 是一个线性函数，所以 $\left{X \in \mathbf{S}^{n} \mid z^{T} X z \geq 0\right}$ 实质是 $\mathrm{S}^n_+$ 中的半平面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要注意&lt;strong&gt;两个凸集的并不是凸集&lt;/strong&gt;。事实上，如果 $C_1, C_2$ 是凸集，那么成立：&lt;/p&gt;
&lt;p&gt;$$
\operatorname{conv}(C_1\cup C_2) = C_1 + C_2\
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仿射变换（affine transformation）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 $C$ 是一个凸集，$f$ 是一个有着形式 $f(x)=Ax+b$ 的仿射函数，那么 $f(C), f^{-1}(C)$ 都是凸集。&lt;/p&gt;
&lt;p&gt;比如椭球就可以看作是球的仿射。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;形如 $A(x)=x_{1} A_{1}+\cdots+x_{n} A_{n} \preceq B$ 的叫做线性矩阵不等式（linear matrix inequality)，其中 $A_i, B \in \mathrm{S}^m$，其解集 ${x \mid A(x) \preceq B}$ 是一个凸集，它是 $\mathrm{S}^n_{+}$ 在仿射函数 $f: \mathrm{R}^n \to \mathrm{S}^m_+,;; f(x)=B-A(x)$ 下的逆像。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透视函数（perspective functions）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义透视函数 $P: \mathrm{R}^{n+1} \to \mathrm{R}^n$，$\operatorname{dom} P=\mathrm{R}^n \times R_{++}$ 且 $P(z, t) = z/t$，那么，如果凸集 $C \subseteq \operatorname{dom} P$ ，那么 $P(C) = {P(x) \mid x \in C}$。&lt;/p&gt;
&lt;p&gt;一个凸集在透视函数的映射下仍然是凸的。透视函数的作用可以理解为是“针孔摄像头”！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性分数变换（Linear fractional transformation）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性分数变换指的是：&lt;/p&gt;
&lt;p&gt;$$
f(x) = \displaystyle\frac{Ax +b}{c^T x + d}, \operatorname{dom} f = {x \mid c^T x + d &amp;gt; 0}\
$$&lt;/p&gt;
&lt;p&gt;凸集，在线性分数变换下的像/原像，都是凸的。&lt;/p&gt;
&lt;h2 id=&#34;广义不等式generalized-inequalities&#34;&gt;广义不等式（generalized inequalities）&lt;/h2&gt;
&lt;h3 id=&#34;正规锥proper-cones&#34;&gt;正规锥（proper cones）&lt;/h3&gt;
&lt;p&gt;这是一个很重要的概念！如果一个锥是闭凸，并且内点集非空（solid），并且 pointed，就称它为 proper cone。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pointed: $x \in K, -x \in K \Longrightarrow x = 0$; cone $K$ Contains no line。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看这个概念很突兀。&lt;strong&gt;proper cone 最重要的作用是能定义一个集合上的偏序关系（partial ordering）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$
x \preceq_{K} y \Longleftrightarrow y-x \in K;; , ;x \prec_{K} y \Longleftrightarrow y-x \in \mathbf{int}K\
$$&lt;/p&gt;
&lt;p&gt;如果取 $K=\mathrm{R}_+$，那么得到的序关系就是正常的实数比较。&lt;/p&gt;
&lt;p&gt;如果取 $K=\mathrm{R}^{n}_+$，那么向量 $\vec{x}\preceq\vec{y}$ 当且仅当每个分量  $x_i \leq y_i$。&lt;/p&gt;
&lt;p&gt;$\mathrm{S^{n}&lt;em&gt;+}$ 是 $\mathrm{S^n}$ 中的一个 $\mathrm{proper; cone}$，$X\preceq&lt;/em&gt;{K} Y$，当且仅当 $Y-X$ 是半正定的；$X\prec_{K} Y$，意味着 $Y-X$是正定的，所以很多时候我们直接简写 $X\succ 0$ 来声明$X$是正定矩阵；同时简写 $x \succ 0$ 声明向量 $x$ 的各个分量都大于0。&lt;/p&gt;
&lt;p&gt;这样的偏序关系有非常良好的性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
x \preceq_{K} y ;\text { and }; y \preceq_{K} z \Longrightarrow x \preceq_{K} z\
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
x \preceq_{K} y ;\text { and }; u \preceq_{K} v \Longrightarrow x+u \preceq_{K} y+v\
$$&lt;/p&gt;
&lt;p&gt;以上的 $\preceq_K$ 均可换成 $\prec_K$ 。虽然《convex optimization》书上列了很多性质，但是大都不太重要（我认为）。&lt;/p&gt;
&lt;p&gt;更多 proper cone 的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单调非负锥（monotone nonnegative cone）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
K_{m+} = {x \in \mathrm{R}^n \mid x_1 \geq x_2 \geq \cdots \geq x_n \geq 0}\
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多项式锥（cone of polynomials）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
K=\left{c \in \mathrm{R}^{n} \mid c_{1}+c_{2} t+\cdots+c_{n} t^{n-1} \geq 0 \text { for } t \in[0,1]\right}\
$$&lt;/p&gt;
&lt;h3 id=&#34;最大和最小元素&#34;&gt;最大和最小元素&lt;/h3&gt;
&lt;p&gt;有了序关系，自然就会考虑这样一个偏序集的最大/最小的元素（maximum/minimum）。&lt;/p&gt;
&lt;p&gt;显然，如果这样的元素存在，那么必然是唯一的。但实际上，并不是所有的元素都是可比较的（comparable），我们可以藉此定义“极小元”、“极大元”（minimal, maximal），意为，没有元素比它们来的更大/更小，容易知道它们不是唯一的。&lt;/p&gt;
&lt;p&gt;比如0是非负象限锥的最小元，但是不是任意两点都是能比较的。&lt;/p&gt;
&lt;p&gt;用 $x-K$ 表示，所有的可以与 $x$ 比较的、并且小于等于 $x$ 的元素全体，此时 $x$ 是 $S$ 中的极小元，当且仅当：$(x-K) \cap S={x}$。&lt;/p&gt;
&lt;p&gt;类似地，用 $x+K$ 表示所有与 $x$ 可以比较的、并且大于等于 $x$ 的元素全体。&lt;/p&gt;
&lt;p&gt;$K=R^2_+$ 的情况如下图，左图的 $x_1$ 是最小点，而右图的 $x_2$ 是极小点&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-Set/minimal.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;分割和支撑超平面定理&#34;&gt;分割和支撑超平面定理&lt;/h2&gt;
&lt;h3 id=&#34;分割超平面separating-hyperplane&#34;&gt;分割超平面（separating hyperplane）&lt;/h3&gt;
&lt;p&gt;考虑两个&lt;strong&gt;不相交&lt;/strong&gt;的凸集，是不是能找到一个超平面把它们分割开？如果其中一个变成凹集，是不是就做不到了？&lt;/p&gt;
&lt;p&gt;对于 $n$ 维空间中的一个超平面，我们习惯用$\left{x | a^{T} x=b\right}$来表示。一个超平面将全空间分割成两个半空间。&lt;/p&gt;
&lt;p&gt;超平面分割定理，说的就是两个不相交的凸集，一定存在 $a \neq 0$ 的超平面使得在其中一个凸集满足 $a^T x\ge b$，而另一个凸集中成立 $a^T x \leq b$。这个超平面 $\left{x | a^{T} x=b\right}$ 就叫做这两个凸集的分割超平面。&lt;/p&gt;
&lt;p&gt;进一步，如果不等关系&lt;strong&gt;严格成立&lt;/strong&gt;，就说这两个凸集被&lt;strong&gt;严格分割&lt;/strong&gt;（strict separation）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义两个凸集的欧几里得距离是这两个集合中两个点距离的下确界：
$$
\operatorname{dist}(C, D)=\inf \left{|u-v|_{2} | ;u \in C, v \in D\right}\
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看，好像很多的凸集对都是可以被严格分割的。&lt;strong&gt;但注意凸集不一定要是闭的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;两个开的不相交的凸集很容易找到例子说明它们可能不能被严格分割。当两个不相交的凸集都是闭的，比如 $A={(x, y) \mid x y \geq 1, x, y&amp;gt;0}$和 $B={(x, y)  \mid x \leq 0}$，也可能不能被严格分割。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;严格分割只在某些特定的情况下&lt;/strong&gt;，比如&lt;strong&gt;一个闭凸集和这个凸集外的一点&lt;/strong&gt;，这两个凸集是可以被严格分割的。如果这个凸集是开的，并且这个点选为凸集的边界点，那么就不能被严格分割。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;点与凸集的分离定理&lt;/strong&gt;，说的正是闭凸集和集合外一点可以被严格分割；利用它，我们进一步才得到下面的&lt;strong&gt;支持超平面定理&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过上一段的那个结论，我们可以得到，任意一个闭凸集是所有包含这个凸集的半空间的交。如果这些凸集可以是有限个，就说这个凸集是可以被有限生成的。（finitely generated）&lt;/p&gt;
&lt;h3 id=&#34;支撑超平面supporting-hyperplane&#34;&gt;支撑超平面（supporting hyperplane）&lt;/h3&gt;
&lt;p&gt;对凸集 $C$，如果有 $x_{0} \in \mathbf{b d} C=\mathbf{cl} C \backslash \mathbf{ int } C$，并且&lt;/p&gt;
&lt;p&gt;$$
a^{T} x \leq a^{T} x_{0};;; \text { for all } x \in C\
$$&lt;/p&gt;
&lt;p&gt;那么超平面 $\left{x | a^{T} x=a^{T} x_{0}\right}$ 就叫做 $C$ 在 $x_0$ 这点的支撑超平面。凸集的任何个边界点都存在支撑超平面，这就是支撑超平面定理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-Set/supporting.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，支撑超平面定理的逆定理也成立。即如果一个内点集非空的闭集，在每一个边界点上都有一个支撑超平面，那么它是凸的。（虽然这个命题非常直觉，但是证起来可不容易）&lt;/p&gt;
&lt;p&gt;分离和支持超平面定理是优化理论非常基本的定理。&lt;/p&gt;
&lt;h2 id=&#34;对偶锥dual-cones&#34;&gt;对偶锥（dual cones）&lt;/h2&gt;
&lt;p&gt;设 $K$ 是个锥，定义 $K$ 的对偶锥为：&lt;/p&gt;
&lt;p&gt;$$
K^{\ast}=\left{y \mid x^{T} y \geq 0 \text { for all } x \in K\right}\
$$&lt;/p&gt;
&lt;p&gt;顾名思义，$K^{\ast}$ 是一个锥，更有意思的是 $K^\ast$ 总是凸的，不论 $K$ 是不是凸的。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性空间的子空间 $V$ 的对偶锥是其正交补 $V^\perp$。&lt;/li&gt;
&lt;li&gt;二阶锥、非负象限锥和半正定锥的对偶锥是其本身，称其为&lt;strong&gt;自对偶锥（self-dual）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;polyhedron cone ${x \mid Ax \succeq 0}$ 的对偶锥是 ${A^Ty \mid y \succeq 0}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 $\mathrm{S}^n$ 上定义 Frobenius 范数，$\mathrm{S}^n_+$ 的自对偶性源自
$$
\operatorname{tr}(XY) \geq 0 ;\text{ for all} ; X \succeq 0 \Longleftrightarrow Y \succeq 0 \
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$p$ 范数锥 $K = {(x, t) \in \mathrm{R}^{n+1} \mid | x|_ p\leq t}$ 的对偶是 $q$ 范数锥 $K^\ast = {(u, v) \in \mathrm{R}^{n+1} \mid | u |_{\ast} \leq v}$，且 $1/p + 1/q = 2$。&lt;/p&gt;
&lt;p&gt;从几何上看，$K^\ast$ 中任意一点与 $K$ 中所有点的夹角不超过90°。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-Set/dual-cone.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对偶锥有以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$K^\ast$ 闭且凸（closed and convex）&lt;/li&gt;
&lt;li&gt;$K_1 \subseteq K_2 \Longrightarrow K_2^\ast\subseteq K_1^\ast$&lt;/li&gt;
&lt;li&gt;如果 $K$ 有非空内点，那么 $K^\ast$ 不包含任何直线（pointed）&lt;/li&gt;
&lt;li&gt;$K^{\ast\ast}$  是 $\operatorname{conv} K$ 的闭包，从而，如果 $K$ 是闭且凸的，那么 $K=K^{\ast\ast}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;pointed: if $x\in K, -x \in K$，then $x=0$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些性质说明如果 $K$ 是一个 proper cone，那么 $K^\ast$ 也是一个 proper cone，并且 $K=K^{\ast\ast}$。&lt;/p&gt;
&lt;h3 id=&#34;对偶广义不等式&#34;&gt;对偶广义不等式&lt;/h3&gt;
&lt;p&gt;之前我们已经知道 proper cone $K$ 能诱导出一个偏序关系。现在$K^\ast$也是一个 proper cone，通过 $K^\ast$ 也能定义一个偏序关系了。&lt;/p&gt;
&lt;p&gt;此外，通过对偶性可以给出广义不等式的等价命题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x \preceq_{K} y \Leftrightarrow \lambda^{T} x \leq \lambda^{T} y ,; ; \forall \lambda \succeq_{K^{\ast}} 0$&lt;/li&gt;
&lt;li&gt;$x \prec_{K} y \Leftrightarrow  \lambda^{T} x&amp;lt;\lambda^{T} y,;;  \forall \lambda \succeq_{K^{\ast}} 0, \lambda \neq 0 .$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过定义很容易验证上图的结论。&lt;/p&gt;
&lt;p&gt;上式的含义是，&lt;strong&gt;对偶锥中的每个元素（向量）可以看成原来锥的一个合法的投影方向，原来锥上两个点在这些合法的投影方向上序不变！&lt;/strong&gt; 在锥形式的对偶中就要用到这条性质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since $K=K^{\ast\ast}$, we have $\lambda \preceq_{K^\ast} \mu$ if and only if $\lambda^{T} x \leq \mu^{T} x$ for all $x \succeq_K 0$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;对偶不等式与最小元极小元&#34;&gt;对偶不等式与最小元/极小元&lt;/h3&gt;
&lt;p&gt;借助对偶性可以建立起最小元和极小元的相关理论。&lt;/p&gt;
&lt;p&gt;对于最小元，$x$ 是 $S$ 的最小元当且仅当，$\forall \lambda \succ_{K^\ast} 0$， $x$ 是问题 $\min_{z\in S} ;\lambda^T z$ 的最优解。&lt;/p&gt;
&lt;p&gt;对于极小元，没有充分必要的条件。其充分条件是：如果 $\exists \lambda \succ_{K^\ast} 0$ 并且 $x$ 是问题 $\min_{z\in S} ;\lambda^T z$ 的最优解，那么 $x$ 就是 $S$ 的极小元。（找到一个方向，在这个方向上的投影是最小的）。如果 $S$ 是凸集，这就是充分必要的。&lt;/p&gt;
&lt;p&gt;（完结撒花）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第二部分&#34;&gt;第二部分&lt;/h2&gt;
&lt;p&gt;这是一条分割线，如果有时间，我会在下面继续补充一些重要的知识。&lt;/p&gt;
&lt;h3 id=&#34;支撑函数&#34;&gt;支撑函数&lt;/h3&gt;
&lt;p&gt;一个集合 $C$ 的支撑函数（support function）定义为：&lt;/p&gt;
&lt;p&gt;$$
S_C(y) = \sup, {y^Tx \mid x \in C}
$$&lt;/p&gt;
&lt;p&gt;容易看到，支撑函数是一个齐次函数（homogeneous），并且不论集合 $C$ 是什么，$S_C$ 都是凸函数！&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点集 ${a_0}$ 的支撑函数是 $S(y) = a_0^T y$&lt;/li&gt;
&lt;li&gt;半径为 1 的单位球的支撑函数是 $S(y) = | y|_2$&lt;/li&gt;
&lt;li&gt;$\mathcal{U} = {x \mid | x - \mu | \leq 1}$ 的支撑函数是 $S_{\mathcal{U}} (y) = y^T \mu + | y|_\ast$ （这个在鲁棒优化里面有应用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这个定理说明，一个闭凸集被它的支撑函数完全刻画：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果 $C$ 和 $D$ 是闭凸集，那么 $C = D$ 当且仅当 $S_C = S_D$&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假如 $S_C = S_D$，先证明 $D \subseteq C$；假如说存在一点 $x_0 \in D, x_0 \notin C$，因为 $C$ 是闭集，而闭集和闭集外一点是可以找到超平面严格分割的，于是，存在 $a \neq 0$，使得 $a^T x_0 &amp;gt; b$，且 $a^T x &amp;lt; b, ,\forall x  \in C$，这意味着：&lt;/p&gt;
&lt;p&gt;$$
\sup &lt;em&gt;{x \in C} a^{T} x \leq b&amp;lt;a^{T} x&lt;/em&gt;{0} \leq \sup _{x \in D} a^{T} x \
$$&lt;/p&gt;
&lt;p&gt;与 $S_C = S_D$ 矛盾，这就证明了 $D \subseteq  C$，于是 $D=C$。&lt;/p&gt;
&lt;h4 id=&#34;支撑函数的几何意义&#34;&gt;支撑函数的几何意义&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;../figures/Convex-Set/support.png&#34; alt=&#34;support function&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于每一个 $a \in \mathrm{R}^n$ ，借助支撑函数都能找到包含 $C$ 的一个支撑超平面：&lt;/p&gt;
&lt;p&gt;$$
H_a = { y \mid  y^T a \leq S_C(a)} \
$$&lt;/p&gt;
&lt;p&gt;这个超平面以 $a$ 为法向量。&lt;/p&gt;
&lt;p&gt;在上图中 $y$ 引出的支撑超平面就是虚线标的那条。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用支撑函数可以证明，一个闭凸集等于它所有的支撑半平面的交集。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;对偶范数的进一步理解&#34;&gt;对偶范数的进一步理解&lt;/h3&gt;
&lt;p&gt;当我们在研究 $X = \mathrm{R}^n$ 的时候（此时没有引入范数），我们会发现 $\mathrm{R}^n$ 的对偶空间 $X^\ast$ 和 $\mathrm{R}^n$ 是线性同构的，如果我们在 $\mathrm{R}^n$ 中引入范数，那么它的对偶空间的元素，也会有随之定义的算子范数！&lt;/p&gt;
&lt;p&gt;在 $\mathrm{R}^n$ 空间中，范数 $| \cdot |$ 的对偶范数被定义为：&lt;/p&gt;
&lt;p&gt;$$
|z|_{\ast}=\sup \left{z^{T} x \mid|x| \leq 1\right} \
$$&lt;/p&gt;
&lt;p&gt;我们知道 $(\mathrm{R}^n, |\cdot |)$ 是一个 Banach space，该空间上每一个元素 $z$ 都能诱导出一个 linear functional：&lt;/p&gt;
&lt;p&gt;$$
f_z(x) = z^T x \
$$&lt;/p&gt;
&lt;p&gt;这个 linear functional $f_z$ 的算子范数就是 $z$ 的对偶范数！所以，$(\mathrm{R}^n, | \cdot |)$ 的对偶空间是 $(\mathrm{R}^n, |\cdot |_\ast)$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\mathrm{R}^n$ 上的所有线性泛函都具有形式：$f(x) = a^T x$.&lt;/p&gt;
&lt;p&gt;见：https://math.stackexchange.com/questions/3377554/show-that-any-linear-function-f-mathbbrn-to-mathbbr-is-of-the-form-fx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据对偶范数的定义可以得到不等式：&lt;/p&gt;
&lt;p&gt;$$
|x | \cdot |z|_\ast \leq |x^T z| \
$$&lt;/p&gt;
&lt;p&gt;在矩阵空间 $\mathrm{R}^{m\times n}$ 上，类似的，有限维线性空间与其对偶空间都是线性同构的，假如我们在 $\mathrm{R}^{m\times n}$ 引入谱范数（spectrum norm），即矩阵最大的奇异值，类似可以在矩阵空间上构造线性泛函：&lt;/p&gt;
&lt;p&gt;$$
f_Z (X) = \operatorname{tr}(Z^T X) \
$$&lt;/p&gt;
&lt;p&gt;这个由矩阵 $Z$ 诱导出的线性泛函，它的算子范数：&lt;/p&gt;
&lt;p&gt;$$
|Z|&lt;em&gt;{2 *}=\sup \left{\operatorname{tr}\left(Z^{\top} X\right) \mid|X|&lt;/em&gt;{2} \leq 1\right} = \sum_i\sigma_i(Z) \
$$&lt;/p&gt;
&lt;p&gt;就是核范数（nuclear norm），即矩阵所有奇异值的和。&lt;/p&gt;
&lt;h3 id=&#34;近似的凸集表示定理&#34;&gt;近似的凸集表示定理&lt;/h3&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/" term="运筹与优化" label="运筹与优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E5%87%B8%E9%9B%86/" term="凸集" label="凸集" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E9%94%A5/" term="锥" label="锥" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Random vectors in high dimensions</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/analysis/hdp3/" />
            <id>https://allenz-me.github.io/posts/analysis/hdp3/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本书第三章主要讲的是高维空间中的随机向量。 第二章介绍了随机变量的集中程度，自然我们会……</summary>
            
                <content type="html">&lt;!-- # Random vectors in high dimensions --&gt;
&lt;p&gt;本书第三章主要讲的是高维空间中的随机向量。&lt;/p&gt;
&lt;p&gt;第二章介绍了随机变量的集中程度，自然我们会进一步关注随机向量的集中程度。本章研究的主要内容就是维数非常高的随机向量 $X = (X_1, X_2, \dots, X_n) \in \mathbb{R}^n$。数据科学中高维分布无处不在！&lt;/p&gt;
&lt;h2 id=&#34;concentration-of-the-norm&#34;&gt;Concentration of the norm&lt;/h2&gt;
&lt;p&gt;高维的随机向量 $X$ 的样本是欧式空间中的一个点，因此我们会用&lt;strong&gt;到原点的欧式距离$|X |_2$来刻画它的集中程度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先从最简单的随机向量考虑起，如果 $X=(X_1, X_2, ..., X_n)$ 各个分量都是独立零均值且单位方差的随机变量，则：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{E}|X|&lt;em&gt;{2}^{2}=\mathbb{E} \sum&lt;/em&gt;{i=1}^{n} X_{i}^{2}=\sum_{i=1}^{n} \mathbb{E} X_{i}^{2}=n \
$$&lt;/p&gt;
&lt;p&gt;这说明大致上 $\lVert X \rVert_2 \sim \sqrt{n}$。**如果 $X$ 的各个分量都是次高斯随机变量，那么这足以保证 $X$ 大致分布在以 $\sqrt{n}$ 为半径的球面附近了。**此时成立不等式：&lt;/p&gt;
&lt;p&gt;$$
\mathbb{P}\left{\left||X|_{2}-\sqrt{n}\right| \geq t\right} \leq 2 \exp \left(-\frac{c t^{2}}{K^{4}}\right) \quad \text { for all } t \geq 0 \
$$&lt;/p&gt;
&lt;p&gt;这意味着，$X$ 的样本点都集中在半径为 $\sqrt{n}$ 的球面附近！&lt;/p&gt;
&lt;h2 id=&#34;isotropic-random-vectors&#34;&gt;Isotropic random vectors&lt;/h2&gt;
&lt;p&gt;不失一般性，只考虑那些零均值的随机向量，这时候它们的协方差矩阵表示为 $\mathbb{E}XX^T$。协方差矩阵一定是一个半正定矩阵。高斯分布协方差矩阵的特征值和特征向量揭示了分布情况，在最大特征值对应的特征向量方向，分布得更加广泛一些。&lt;/p&gt;
&lt;p&gt;如果随机向量 $X$ 的协方差矩阵只有几个较大的特征值，而剩余的特征值都很小，说明该随机向量只在很小的几个维度包含信息。&lt;/p&gt;
&lt;p&gt;定义 &lt;em&gt;&lt;strong&gt;Isotropic random vectors&lt;/strong&gt;&lt;/em&gt; 是那些零均值并且满足 $\Sigma=\mathbb{E}XX^T=I_n$ 的随机向量。这种随机向量的各个分量之间没有相关性，但并不代表它们是独立的。对于一般的随机向量，可以用变换 $Z:=\Sigma^{-1/2}(X - \mu)$ 来标准化，这可以消除分量之间的相关性。&lt;/p&gt;
&lt;p&gt;各向同随机向量只是一种抽象的存在，但是它所具有的性质非常让人惊讶，而这些性质都可以落到更具体的分布之上。&lt;/p&gt;
&lt;p&gt;首先，是 $\mathbb{E}| X|_2^2=n$，这是一个显而易见的长度上的性质。&lt;/p&gt;
&lt;p&gt;接着，&lt;strong&gt;设 $X, Y$ 都是各向同随机向量，那么 $X, Y$ 的夹角，会呈现出随着维数 $n$ 的增加而趋于正交的特点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;$$
\mathbb{E}\langle X, Y\rangle^{2}=\mathbb{E}&lt;em&gt;{Y} \mathbb{E}&lt;/em&gt;{X}\left[\langle X, Y\rangle^{2} \mid Y\right] = \mathbb{E}\langle X, Y\rangle^{2}=\mathbb{E}&lt;em&gt;{Y}|Y|&lt;/em&gt;{2}^{2} = n \
$$&lt;/p&gt;
&lt;p&gt;所以 $|\langle X, Y \rangle| \sim \sqrt{n},, |X| \sim \sqrt{n}, |Y| \sim \sqrt{n}$，即有：$| \langle X, Y \rangle| \sim \frac{1}{\sqrt{n}}$。如果$X_i \sim X,; Y_i \sim Y$，这两个高维空间中的样本点，随着维数的增加，其夹角的余弦值是趋于0的。&lt;/p&gt;
&lt;p&gt;举个例子，当 $n$ 很大的时候，从 $\mathcal{N}(0, I_n)$ 中抽两个样本点，这两个点几乎是正交的。&lt;/p&gt;
&lt;p&gt;最后呢，结合上述两点，联系勾股定理不难理解 $\mathbb{E}| X - Y |_2^2 = 2n$。&lt;/p&gt;
&lt;p&gt;接下来是各向同随机向量的例子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;球面上的均匀分布：$X \sim \operatorname{Unif}\left(\sqrt{n} S^{n-1}\right)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，该分布不包含球的内部。这是一个典型的，各分量不相关，但是不独立的随机向量。它各向同的证明要用到曲线积分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高维对称伯努利分布：$X \sim \operatorname{Unif}\left({-1,1}^{n}\right)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准的多元正态分布：$g \sim \mathcal N\left(0, I_{n}\right)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正态分布的一大特点就是不相关即独立。&lt;strong&gt;另一个重要性质是，任意的多元正态分布投影在某条直线上，得到的仍然是正态分布，这是后续定义次高斯随机向量的出发点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然低维的标准正态分布，给我们的感觉是，集中在原点附近的球内，但是，随着维数的增加，它的次高斯性开始显现了，本文最开始提到，$| g|$ 在 $n$ 很大的时候集中在半径为 $\sqrt{n}$ 的球面上。&lt;/p&gt;
&lt;p&gt;$$
\mathcal{N} (0, I_n) \to \operatorname{Unif}\left(\sqrt{n} S^{n-1}\right): \text{ as }: n \to \infty \
$$&lt;/p&gt;
&lt;p&gt;另外两个例子，分别是用在信号处理和凸几何中的。一个是 &lt;em&gt;frame&lt;/em&gt;，它是非常稀疏的离散各向同分布。另一个讲的是，对于$\mathrm{R}^n$中每个内点非空的凸集$K$，都可以对应一个零均值随机向量$X$。如果$\Sigma = \mathbb{E} XX^T$，那么$Z \sim \operatorname{Unif}\left(\Sigma^{-1 / 2} K\right)$是一个各向同随机向量。线性变换$\Sigma ^ {-1/2}$可以把凸集$K$的形状变得更加规整。&lt;/p&gt;
&lt;h2 id=&#34;sub-gaussian-distributions-in-higher-dimensions&#34;&gt;Sub-gaussian distributions in higher dimensions&lt;/h2&gt;
&lt;p&gt;次高斯分布，本质是正态分布集中性质的推广，它的定义思想，来自正态分布的一条重要性质：投影在任意一个方向上都是正态分布，并且分布被这些投影所决定！&lt;/p&gt;
&lt;p&gt;因此，定义 $X$ 是次高斯随机向量，当且仅当对任意的 $x \in \mathrm{R}^n$，$\langle X, x \rangle$ 是次高斯随机变量。且定义其次高斯模为：&lt;/p&gt;
&lt;p&gt;$$
|X|&lt;em&gt;{\psi&lt;/em&gt;{2}}=\sup &lt;em&gt;{x \in S^{n-1}}|\langle X, x\rangle|&lt;/em&gt;{\psi_{2}} \
$$&lt;/p&gt;
&lt;p&gt;如果随机向量的各个分量都是次高斯随机变量，那么它自然能成为次高斯随机向量。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E5%88%86%E6%9E%90%E4%B8%8E%E6%A6%82%E7%8E%87/" term="分析与概率" label="分析与概率" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E9%AB%98%E7%BB%B4%E6%A6%82%E7%8E%87/" term="高维概率" label="高维概率" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%90%91%E9%87%8F/" term="随机向量" label="随机向量" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E6%AC%A1%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/" term="次高斯分布" label="次高斯分布" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">纳什均衡与相关均衡</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/operations/nash-corr/" />
            <id>https://allenz-me.github.io/posts/operations/nash-corr/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">策略 博弈论中的策略有纯策略和混合策略之分。但是它们可以有统一的数学逻辑。 参与人集合$……</summary>
            
                <content type="html">&lt;!-- #! https://zhuanlan.zhihu.com/p/367426959

# 纳什均衡与相关均衡 --&gt;
&lt;h2 id=&#34;策略&#34;&gt;策略&lt;/h2&gt;
&lt;p&gt;博弈论中的策略有纯策略和混合策略之分。但是它们可以有统一的数学逻辑。&lt;/p&gt;
&lt;p&gt;参与人集合$N$，每个人$i\in N$都有一个行动集合$A_i$，记$A=\times_{i=1}^N A_i$是行动集合的笛卡尔积，决策时，参与者$i$从$A_i$中选出一个$a_i$，所有人的决策构成一个行动组合$a=(a_j)_{j\in N}$。&lt;/p&gt;
&lt;p&gt;定义$\Delta (A_i)$表示$A_i$上所有概率分布的集合，则纯策略和混合策略都是$\Delta (A_i)$内的元素。&lt;/p&gt;
&lt;p&gt;我们可以策略看成是一个概率向量($\mathbf{1}^Tp=1$)，则纯策略就是一个“退化”的混合策略了。&lt;/p&gt;
&lt;p&gt;对任一 $a_{-i} \in A_{-i}$ 定义 $B_{i}\left(a_{-i}\right)$ 为参与人 $i$ 在给定 $a_{-i}$ 下最佳行动集合（best response）。&lt;/p&gt;
&lt;p&gt;对于全体参与者，可以定义集值函数$B=\times_{i=1}^N B_i: A\to A$。对纳什均衡，就是：$a^{&lt;em&gt;} \in B\left(a^{&lt;/em&gt;}\right)$。翻译过来就是，每个玩家的策略，都是对其他玩家策略的最佳反应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集值函数，其实就是一个多值函数，这时候我们把它的值域看成是一个集类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，纳什均衡的存在性，即等价于集值映射$B$是否存在不动点。&lt;/p&gt;
&lt;h2 id=&#34;纳什均衡&#34;&gt;纳什均衡&lt;/h2&gt;
&lt;p&gt;最简单的纳什均衡（Nash equilibrium, NE）是纯策略纳什均衡，如果所有的参与者都有&lt;strong&gt;无限策略&lt;/strong&gt;，那么纯策略纳什均衡的存在性是可以保证的。&lt;/p&gt;
&lt;p&gt;Nash定理，作为一个非常著名的定理，说的是任何一个有限策略博弈都存在混合策略纳什均衡。&lt;/p&gt;
&lt;p&gt;除去大家都熟知的纳什均衡，还有其它均衡的概念。&lt;/p&gt;
&lt;h2 id=&#34;强纳什均衡&#34;&gt;强纳什均衡&lt;/h2&gt;
&lt;p&gt;顾名思义，强纳什均衡（strong Nash equilibrium, SNE）就是比纳什均衡更强的概念，它指的是，在纳什均衡的基础上，没有子联盟愿意改变自己的策略以换来每个人更高的收益。&lt;/p&gt;
&lt;p&gt;囚徒困境存在一个纯策略纳什均衡，但它不是强纳什均衡，因为这两名囚徒可以组成“子联盟”来提高每个人的收益。&lt;/p&gt;
&lt;p&gt;强纳什均衡往往在多人博弈中被研究，比如稳定婚姻问题：考虑$n$个男人和$n$个女人，每个人对异性都有严格的偏好，他们配对以后，如果没有一组夫妻愿意交换他们的伴侣，那么这一组婚姻就被认为是稳定的。&lt;/p&gt;
&lt;p&gt;通俗点说，如果形成了强纳什均衡，就不会存在你和隔壁老王互相觉得对方的老婆更漂亮的情况。&lt;/p&gt;
&lt;h2 id=&#34;相关均衡&#34;&gt;相关均衡&lt;/h2&gt;
&lt;p&gt;相关均衡（correlated Equilibrium, CE）是一个比纳什均衡更弱的概念。数学一点说，相关均衡就是行动集$A$上的一个概率分布。当然，这个概率分布还需要满足一些条件。&lt;/p&gt;
&lt;p&gt;先解释$A$上的概率分布这件事情，如下是一个对称博弈：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{|c|c|c|}\hline &amp;amp; d &amp;amp; c \\hline d &amp;amp; 0,0 &amp;amp; 4,1 \\hline c &amp;amp; 1,4 &amp;amp; 3,3 \\hline\end{array}\\
$$&lt;/p&gt;
&lt;p&gt;显然，$(1, 4)$和$(4, 1)$是博弈的两个纯策略纳什均衡，此外，每个玩家以$\frac{1}{2}$的概率选$c$或$d$是一个混合策略纳什均衡。&lt;/p&gt;
&lt;p&gt;假如说这时候有一个上帝，对这两个玩家说，你们两个人的行动，一共有4种情况，你们按如下的概率分布去进行吧：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{|c|c|c|}\hline &amp;amp; d &amp;amp; c \\hline d &amp;amp; 0 &amp;amp; 3 / 8 \\hline c &amp;amp; 3 / 8 &amp;amp; 1 / 4 \\hline\end{array}\\
$$&lt;/p&gt;
&lt;p&gt;上帝以相应的概率从$(c, d), (c, c), (d, c)$中选择一个，然后分别建议这两个玩家按照自己的指示去做抉择。&lt;/p&gt;
&lt;p&gt;这时候，两个玩家会遵从上帝的指示吗？&lt;/p&gt;
&lt;p&gt;我们先站在玩家一（row player）的立场上去看一下，“假如玩家二（column player）是听话的，如果上帝让我选$c$，这时候玩家二选$c, d$的概率分别是$\frac{3}{5}, \frac{2}{5}$，我选$c$的期望得益是$\frac{9}{5}$，选$d$的期望得益是$\frac{8}{5}$，所以我会选择听从上帝的指示。又如果上帝让我选$d$，这时候玩家二必然选$c$，我选择$d$的得益是$4$，选$c$的得益是$3$，所以我也会听从。”&lt;/p&gt;
&lt;p&gt;所以，如果有这样一个比较有权威的第三方能够给出一些合理的意见，就可以规避混合策略纳什均衡中出现$(d, d)$双方得益都为0这种情况，从而提高整个系统的收益情况。&lt;/p&gt;
&lt;p&gt;值得注意的是，纳什均衡也是相关均衡，它可以看做是相关均衡的特殊情况。（混合策略）纳什均衡下每个玩家做出选择都是&lt;strong&gt;独立&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;对一个有$n$个玩家，每个玩家两种行为的博弈来说，它的纳什均衡涉及$2n$个数，但是相关均衡有$2^n$个数。&lt;/p&gt;
&lt;p&gt;从数学上说，相关均衡是行动集合$A$上的一个概率分布$\mathcal{D}$，使得对于任何的玩家$i$和行动$a^*_i$，都有：&lt;/p&gt;
&lt;p&gt;$$
\mathrm{E}&lt;em&gt;{a \sim \mathcal{D}}\left[u&lt;/em&gt;{i}(a) \mid a_i\right] \geq \mathrm{E}&lt;em&gt;{a \sim \mathcal{D}}\left[u&lt;/em&gt;{i}\left(a_{i}^{&lt;em&gt;}, a_{-i}\right) \mid a_{i}\right], \quad \forall i, a^&lt;/em&gt;_i\
$$&lt;/p&gt;
&lt;h2 id=&#34;粗糙相关均衡&#34;&gt;粗糙相关均衡&lt;/h2&gt;
&lt;p&gt;如果把对$a_i$取条件期望拿掉，就是粗糙相关均衡（coarse correlated equilibrium）：&lt;/p&gt;
&lt;p&gt;$$
\mathrm{E}&lt;em&gt;{a \sim \mathcal{D}}\left[u&lt;/em&gt;{i}(a) \right] \geq \mathrm{E}&lt;em&gt;{a \sim \mathcal{D}}\left[u&lt;/em&gt;{i}\left(a_{i}^{&lt;em&gt;}, a_{-i}\right) \right], \quad \forall i, a^&lt;/em&gt;_i\
$$&lt;/p&gt;
&lt;p&gt;相关均衡在收到上帝给的指令后，每个玩家会自发地听从指令。而粗糙相关均衡是知道概率分布之后，哪怕还没接收到一个具体的指令时就表示会服从这个指令。&lt;/p&gt;
&lt;p&gt;以下是粗糙相关均衡的一个示例：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{|c|c|c|c|}\hline &amp;amp; \mathrm{A} &amp;amp; \mathrm{B} &amp;amp; \mathrm{C} \\mathrm{A} &amp;amp; (1,1) &amp;amp; (-1,-1) &amp;amp; (0,0) \\mathrm{B} &amp;amp; (-1,-1) &amp;amp; (1,1) &amp;amp; (0,0) \\mathrm{C} &amp;amp; (0,0) &amp;amp; (0,0) &amp;amp; (-1.1,-1.1) \\hline\end{array}\
$$&lt;/p&gt;
&lt;p&gt;这个博弈行动集上的一个概率分布如下：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{|c|c|c|c|}\hline &amp;amp; \mathrm{A} &amp;amp; \mathrm{B} &amp;amp; \mathrm{C} \\mathrm{A} &amp;amp; 1 / 3 &amp;amp; &amp;amp; \\mathrm{~B} &amp;amp; &amp;amp; 1 / 3 &amp;amp; \\mathrm{C} &amp;amp; &amp;amp; &amp;amp; 1 / 3 \\hline\end{array}\
$$&lt;/p&gt;
&lt;p&gt;首先它不是一个相关均衡，因为上帝如果掷出了$(C, C)$，两个玩家的都会选择不听从。&lt;/p&gt;
&lt;p&gt;但是在上帝随机做选择之前，如果玩家一决定服从上帝的协调，那么玩家二最优的选择也是服从协调。&lt;/p&gt;
&lt;p&gt;容易看出，粗糙相关均衡是一种比相关均衡更弱的概念。它与相关均衡的区别，可以这样理解：你聘请了一个理财顾问，每年都会给你规划资产配置的方案，你看过方案之后决定听从建议（相关均衡），或者没看方案就决定听从建议（粗糙相关均衡）。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了博弈论中均衡的概念。从强到弱分别是 SNE &amp;gt; NE &amp;gt; CE &amp;gt; CCE。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E8%BF%90%E7%AD%B9%E4%B8%8E%E4%BC%98%E5%8C%96/" term="运筹与优化" label="运筹与优化" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" term="博弈论" label="博弈论" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">随机个随机变量的和的性质</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/analysis/double-random/" />
            <id>https://allenz-me.github.io/posts/analysis/double-random/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2021-01-01T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">设 $Y_1, Y_2, ...$ 是独立同分布且二阶矩有限的随机变量，$N$ 是一个与 $Y$ 独立且取值为正整数的随机……</summary>
            
                <content type="html">&lt;!-- #! https://zhuanlan.zhihu.com/p/421364730

# 随机个随机变量的和的性质 --&gt;
&lt;p&gt;设 $Y_1, Y_2, ...$ 是独立同分布且二阶矩有限的随机变量，$N$ 是一个与 $Y$ 独立且取值为正整数的随机变量。令：&lt;/p&gt;
&lt;p&gt;$$
X = Y_1 + Y_2 + ... + Y_N
$$&lt;/p&gt;
&lt;p&gt;这里 $X$ 是一个随机个独立同分布随机变量的和。那么，$X$ 的方差和期望该如何计算呢？&lt;/p&gt;
&lt;p&gt;首先，由条件期望公式，我们知道 $E[X] = E[E[X|N]]$，在给定 $N$ 时，$E[X|N] = N E[Y]$，所以：&lt;/p&gt;
&lt;p&gt;$$
E[X] = E[N] \cdot E[Y] \
$$&lt;/p&gt;
&lt;p&gt;计算 $X$ 的方差，需要借助条件方差公式；条件方差，跟条件期望一样，它也是一个随机变量，其定义如下：&lt;/p&gt;
&lt;p&gt;$$
var(X|Y) = E[(X - E[X|Y])^2|Y] = E[X^2|Y] - E^2[X|Y] \
$$&lt;/p&gt;
&lt;p&gt;条件方差公式如下：&lt;/p&gt;
&lt;p&gt;$$
var(X) = E[var(X|Y)] + var(E[X|Y])
$$&lt;/p&gt;
&lt;p&gt;这个公式把右边展开一下就能证了。&lt;/p&gt;
&lt;p&gt;应用条件方差公式:&lt;/p&gt;
&lt;p&gt;$$
var(X) = E[var(X|N)] + var(E[X|N])
$$&lt;/p&gt;
&lt;p&gt;其中：
$$
E[var(X|N)]=E[var(Y) \cdot N]=var(Y)\cdot E[N] \
var(E[X|N]) = var(N\cdot E[Y]) = var(N) \cdot E^2[Y] \
$$&lt;/p&gt;
&lt;p&gt;于是：&lt;/p&gt;
&lt;p&gt;$$
var(X) = var(Y)\cdot E[N] + var(N) \cdot E^2[Y] \
$$&lt;/p&gt;
&lt;p&gt;现在问题来了，$X$ 的高阶矩怎么计算呢？&lt;/p&gt;
&lt;p&gt;高阶矩没有类似的公式（我不知道），所以，这个计算可能需要我们回归高阶矩计算的内在方法————矩母函数。&lt;/p&gt;
&lt;p&gt;$$
m_X(t) = E[e^X] = E[E[e^X|N]] = E[(m_Y(t))^N] \
$$&lt;/p&gt;
&lt;p&gt;对 $m_X(t)$ 求导，期望相当于积分，因此应用积分求导公式有：&lt;/p&gt;
&lt;p&gt;$$
m^\prime_X(t) = E[N(m_Y(t))^{N-1}m_Y^\prime (t)]\
$$&lt;/p&gt;
&lt;p&gt;计算在 $t=0$ 处的值，即有：$E[X] = E[N]E[Y]$。高阶矩可以类似计算，但注意要加上条件：$N, Y$ 的高阶矩也是存在的。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E5%88%86%E6%9E%90%E4%B8%8E%E6%A6%82%E7%8E%87/" term="分析与概率" label="分析与概率" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/" term="随机变量" label="随机变量" />
                            
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/%E7%9F%A9%E6%AF%8D%E5%87%BD%E6%95%B0/" term="矩母函数" label="矩母函数" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Java 流的妙用</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/coding/java-stream/" />
            <id>https://allenz-me.github.io/posts/coding/java-stream/</id>
            <updated>2022-01-28T16:42:38&#43;08:00</updated>
            <published>2019-11-15T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">求数组的最大值、最小值、和... 等 在Java中，基本类型流只支持 int、long、d……</summary>
            
                <content type="html">&lt;ol&gt;
&lt;li&gt;求数组的最大值、最小值、和... 等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Java中，基本类型流只支持 &lt;code&gt;int、long、double&lt;/code&gt; 三种类型。一是可以通过 &lt;code&gt;IntSream.range&lt;/code&gt; 方法创建；二是通过 &lt;code&gt;Arrays.stream( )&lt;/code&gt; 中传入一个基本类型的数组进行创建&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getAsInt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 类似于python的reduce函数，提供一个二元运算符
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reduce&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;reduce&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 6，所有数之积
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orelse&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;reduce&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;orElse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;Arrays.stream(nums).max()&lt;/code&gt; 返回的是一个 &lt;code&gt;Optinal&amp;lt;int&amp;gt;&lt;/code&gt; 对象，因为流可能是空的，所以 &lt;code&gt;getAsInt&lt;/code&gt; 方法可能会报错，因此 &lt;code&gt;Optinal&amp;lt;int&amp;gt;&lt;/code&gt; 对象提供了一个 &lt;code&gt;orElse(int default)&lt;/code&gt; 方法去处理这种情况。类似于 Python 的 &lt;code&gt;max(nums, default=0)&lt;/code&gt;。而流是空的时候 &lt;code&gt;sum&lt;/code&gt; 方法不会出现问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果 &lt;code&gt;Optional&lt;/code&gt; 装载的泛型类不是基本类型，那么就通过 &lt;code&gt;get&lt;/code&gt; 方法去获得变量的值。&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;列表筛选&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;bb&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;startsWith&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ss&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// collect() 方法接受stream数据并转换类型
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" term="算法与程序设计" label="算法与程序设计" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/java/" term="Java" label="Java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">给定自然数 N，如何快速分解质因数？</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/coding/primers/" />
            <id>https://allenz-me.github.io/posts/coding/primers/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2019-10-27T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">$120=2^3 \times 3 \times 5$ 如上，对一个数分解质因数就是分解成若干个质数的乘积，如果这个数是质数，那么……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;$120=2^3 \times 3 \times 5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上，对一个数分解质因数就是分解成若干个质数的乘积，如果这个数是质数，那么对它分解质因数就是这个数本身。&lt;/p&gt;
&lt;p&gt;一个很朴素的想法是：&lt;/p&gt;
&lt;p&gt;对于从 $2\sim N$ 的每个自然数 $p$，去判断它是否是质数，如果 $p$ 整除 $N$，那么就可以求出 $p$ 在 $N$ 的质因数分解式里的指数&lt;/p&gt;
&lt;p&gt;一个非常简单是实现是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isprime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isprime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;120&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# {2: 3, 3: 1, 5: 1}&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;97&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# {97: 1}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于一个 &lt;code&gt;int&lt;/code&gt; 表示的整数一般不会有超过30个不同的质因数（并且该质因数的指数也一般不超过30，想想这是为什么），因而可以认为空间复杂度是 $O(1)$。&lt;/p&gt;
&lt;p&gt;接下来我们计算一下这种方法的时间复杂度。对于一个自然数 $p$，仅判断它是否是质数需要遍历从3到 $\sqrt p$的所有奇数，用时 $\sqrt p$ ，对于从 2 到 $N$ 的每个奇数都去判断一遍，共计 $O(n \sqrt n)$。&lt;/p&gt;
&lt;p&gt;显然这样做不是最优方法。因为一个数 $N$ 不可能有超过两个大于 $\sqrt N$ 的质因数！！！&lt;/p&gt;
&lt;p&gt;So, 我们只需要把 $N$ 在 $ \sqrt N$ 内做质因数分解，剩下还没有分解掉的就是剩下的那个质因数了。（想想这个数为什么一定是质数）&lt;/p&gt;
&lt;p&gt;还是贴python代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isprime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 跟上面一样，判断是否是质数&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isprime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;However，细心的你可能会发现，好像根本不需要判断质数这一步&lt;/p&gt;
&lt;p&gt;因为有 &lt;code&gt;while&lt;/code&gt; 循环，所以结果中根本不可能分解出非质数（想想这又是为什么）&lt;/p&gt;
&lt;p&gt;所以代码可以简化到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 循环总的执行次数是有限的，因此总的时间复杂度就是 &lt;code&gt;for&lt;/code&gt; 循环带来的 $O(\sqrt n)$ 。&lt;/p&gt;
&lt;p&gt;到这里，我也再想不出什么可以优化这个 &lt;code&gt;for&lt;/code&gt; 循环的方法了。&lt;/p&gt;
&lt;p&gt;最后贴一下C++的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;120&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 结果：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 5: 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 3: 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 2: 3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" term="算法与程序设计" label="算法与程序设计" />
                            
                        
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Java BigInteger</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/coding/java-bigint/" />
            <id>https://allenz-me.github.io/posts/coding/java-bigint/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2019-10-26T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在 C++ 中，没有超过 long long 以上的大整数类了，而 Java 就有大整数类 普通的 int 类型能表示的整数的绝对……</summary>
            
                <content type="html">&lt;p&gt;在 C++ 中，没有超过 &lt;code&gt;long long&lt;/code&gt; 以上的大整数类了，而 Java 就有大整数类&lt;/p&gt;
&lt;p&gt;普通的 &lt;code&gt;int&lt;/code&gt; 类型能表示的整数的绝对值上限是$2^{31} \simeq 10^{(\log_{10}2) \times 31} \simeq 10^{0.3 \times 31}$，其数量级在$10^{9}$&lt;/p&gt;
&lt;p&gt;&lt;code&gt;long&lt;/code&gt; 类型是 $2^{63} \simeq 10^{0.3\times 63}$，数量级不超过 $10^{19}$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如对于Fibonacci数列，其增长速度是 $(\frac{1+\sqrt 5}{2})^n \simeq 1.618^n$，在 $n\ge \frac{19}{\log_{10}{1.618}}\simeq 91$ 时是无法用 &lt;code&gt;long&lt;/code&gt; 类型来保存的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可见，学习 Java 的大整数类 &lt;code&gt;java.math.BigInteger&lt;/code&gt; 是非常有必要的！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.BigInteger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Scanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nextBigInteger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;valueOf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 主要就是这两种构造方法，推荐使用字符串构造
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 下面是一些BigInteger的常用方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;abs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;返回大整数的绝对值&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的和&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;返回两个大整数的按位与的结果&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;andNot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数与非的结果&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;返回两个大整数的商&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;doubleValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;返回大整数的double类型的值&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;floatValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;返回大整数的float类型的值&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;gcd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;返回大整数的最大公约数&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回大整数的整型值&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;longValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回大整数的long型值&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的最大者&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的最小者&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mod&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;用当前大整数对val求模&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;multiply&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的积&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;negate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回当前大整数的相反数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;not&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回当前大整数的非&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的按位或&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回当前大整数的exponent次方&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;remainder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回当前大整数除以val的余数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;leftShift&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;将当前大整数左移n位后返回&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rightShift&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;将当前大整数右移n位后返回&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;subtract&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;返回两个大整数相减的结果&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;toByteArray&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;将大整数转换成二进制反码保存在byte数组中&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;将当前大整数转换成十进制的字符串形式&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;xor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BigInteger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;返回两个大整数的异或&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" term="算法与程序设计" label="算法与程序设计" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/tags/java/" term="Java" label="Java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">给定自然数 N，如何求出所有约数？</title>
            <link rel="alternate" type="text/html" href="https://allenz-me.github.io/posts/coding/none/" />
            <id>https://allenz-me.github.io/posts/coding/none/</id>
            <updated>2022-01-28T18:09:30&#43;08:00</updated>
            <published>2019-10-23T00:00:00&#43;00:00</published>
            <author>
                    <uri>https://io-oi.me/</uri>
                    <email>allenz.me@qq.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">问题：给定自然数 N，如何求出 N 的所有约数？ 如 N = 198，它的约数有：[1, 2, 3, 6, 9, 11,……</summary>
            
                <content type="html">&lt;p&gt;&lt;strong&gt;问题：给定自然数 N，如何求出 N 的所有约数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如 N = 198，它的约数有：[1, 2, 3, 6, 9, 11, 18, 22, 33, 66, 99, 198]&lt;/p&gt;
&lt;p&gt;一个很自然的想法是：对从 2 到 $\displaystyle\frac{N}{2}$ 的所有数进行遍历，看这个数是否能整除N。这样的时间复杂度是 $O(N)$&lt;/p&gt;
&lt;p&gt;有没有更快一点的呢？&lt;/p&gt;
&lt;p&gt;我们可以这样考虑：如果有非平方数 $N=a\times b$，其中 $a&amp;lt;b$，那么一定有 $a&amp;lt;\sqrt N, b &amp;gt; \sqrt N$，对于每一个小于 $\sqrt N$ 的 $N$ 的约数 $a$，都有一个对应的 $b&amp;gt;\sqrt N$，$b$ 也是 $N$ 的约数，因此我们只需要遍历 2 到 $\sqrt N$ 就可以了，每一次整除都对应了 $N$ 的两个约数，最后只需要再考虑一下 $N$ 是不是平方数就可以了。这样，时间复杂度就被优化到了$\sqrt N$，是个非常大的进步了。&lt;/p&gt;
&lt;p&gt;下面贴代码&lt;/p&gt;
&lt;p&gt;Python：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;typing&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
	&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&amp;#39;return all the factors of N&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;sorted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;198&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;    
&lt;span class=&#34;c1&#34;&gt;# [1, 2, 3, 6, 9, 11, 18, 22, 33, 66, 99, 198]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Java：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Divisors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;198&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// stream是Java 8的新语法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sorted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toArray&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;C++&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;divisors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;198&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://allenz-me.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" term="算法与程序设计" label="算法与程序设计" />
                            
                        
                    
                
                    
                
            
        </entry>
    
</feed>
